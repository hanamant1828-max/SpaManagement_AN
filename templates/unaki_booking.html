<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unaki Appointment Booking - Professional Spa Management</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: #f7fafc;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
        }

        .schedule-container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: 2px solid #e2e8f0;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .schedule-grid {
            display: grid;
            grid-template-columns: 220px repeat(8, 250px);
            border: 3px solid #2d3748;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .time-header, .staff-cell, .time-slot {
            border-right: 2px solid #4a5568;
            border-bottom: 1px solid #cbd5e0;
            padding: 16px 12px;
            text-align: center;
            position: relative;
            transition: all 0.2s ease;
        }

        /* Make vertical lines very clear */
        .time-header:not(:last-child),
        .time-slot:not(:nth-child(9n)) {
            border-right: 3px solid #2d3748;
        }

        /* Staff column has extra thick border */
        .staff-cell {
            border-right: 4px solid #667eea !important;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        }

        .time-header {
            background: #2d3748;
            font-weight: 700;
            font-size: 14px;
            color: white;
            border-bottom: 3px solid #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .staff-cell {
            background: #f7fafc;
            text-align: left;
            font-weight: 700;
            position: relative;
            transition: all 0.2s ease;
        }

        .staff-cell:hover {
            background: #edf2f7;
        }

        .staff-name {
            font-size: 14px;
            color: #2d3748;
            margin-bottom: 2px;
            font-weight: 700;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .staff-role {
            font-size: 10px;
            color: #4a5568;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            opacity: 0.8;
            line-height: 1.1;
        }

        .time-slot {
            min-height: 70px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
        }

        .time-slot:hover {
            background: #f0f4ff;
            box-shadow: inset 0 0 0 2px #667eea;
        }

        .time-slot:empty::after {
            content: '+';
            font-size: 24px;
            color: #cbd5e0;
            font-weight: 300;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .time-slot:empty:hover::after {
            opacity: 1;
            color: #667eea;
        }

        .appointment-block {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 8px;
            font-size: 11px;
            line-height: 1.2;
            cursor: pointer;
            min-height: 60px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 12px rgba(102, 126, 234, 0.3);
            overflow: hidden;
        }

        .appointment-block:hover {
            background: #5a67d8;
            border-color: #5a67d8;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .appointment-client {
            font-weight: 700;
            margin-bottom: 1px;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .appointment-service {
            font-size: 9px;
            opacity: 0.85;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 1px;
        }

        .appointment-time {
            font-size: 8px !important;
            opacity: 0.8 !important;
            font-weight: 500 !important;
            margin-top: auto;
        }

        .appointment-duration {
            font-size: 7px !important;
            opacity: 0.7 !important;
            text-align: right;
            margin-top: 1px;
        }

        .break-block {
            background: #ed8936;
            color: white;
            border-radius: 8px;
            padding: 8px;
            font-size: 13px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            cursor: default;
            min-height: 66px;
            z-index: 10;
            border: 2px solid #dd6b20;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .drag-selection {
            position: absolute;
            background: rgba(37, 99, 235, 0.2);
            border: 2px dashed #2563eb;
            border-radius: 4px;
            z-index: 100;
            pointer-events: none;
        }

        .header-controls {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            background: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 14px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-outline-secondary {
            border: 2px solid rgba(102, 126, 234, 0.3);
            color: #667eea;
            border-radius: 12px;
            padding: 10px 20px;
            transition: all 0.3s ease;
            background: white;
        }

        .btn-outline-secondary:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px 20px 0 0;
            border: none;
            padding: 24px;
        }

        .modal-content {
            border-radius: 20px;
            border: none;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .form-label {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-control, .form-select {
            border-radius: 12px;
            border: 2px solid rgba(226, 232, 240, 0.8);
            padding: 12px 16px;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .form-control:focus, .form-select:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .stats-row {
            padding: 24px 32px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-bottom: 1px solid rgba(226, 232, 240, 0.6);
            position: relative;
        }

        .stats-row::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }

        .stat-item {
            text-align: center;
            padding: 16px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            border: 1px solid rgba(226, 232, 240, 0.6);
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
        }

        .stat-number {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .header-controls {
            padding: 32px;
            border-bottom: 1px solid rgba(226, 232, 240, 0.6);
            background: linear-gradient(135deg, white 0%, #f8fafc 100%);
            position: relative;
        }

        .header-controls::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #667eea, transparent);
        }

        /* Enhanced button styles */
        .btn-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .btn-content {
            transition: all 0.3s ease;
        }

        .position-relative {
            position: relative;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        /* Form validation enhancements */
        .was-validated .form-control:invalid {
            border-color: #dc3545;
            animation: shake 0.5s ease-in-out;
        }

        .was-validated .form-control:valid {
            border-color: #28a745;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Enhanced appointment context menu */
        .appointment-context-menu {
            animation: fadeInScale 0.2s ease-out;
        }

        .appointment-context-menu .btn {
            transition: all 0.2s ease;
        }

        .appointment-context-menu .btn:hover {
            transform: translateX(3px);
        }

        /* Tooltip styles */
        .selection-tooltip {
            animation: fadeIn 0.3s ease-out;
        }

        /* Enhanced time slot interactions */
        .time-slot.selecting {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(99, 102, 241, 0.15));
            border: 2px solid #3b82f6;
            transform: scale(1.02);
            transition: all 0.2s ease;
        }

        /* Success animation for stats */
        .stat-item.updated {
            animation: bounce 0.6s ease-in-out;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .spa-context-menu {
                background: #2c2c2c;
                border-color: #444;
                color: #fff;
            }

            .context-menu-item {
                color: #fff;
            }

            .context-menu-item:hover {
                background: #3c3c3c;
            }

            .context-menu-divider {
                background: #444;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="text-center">
            <div class="loading-spinner mx-auto mb-3"></div>
            <div class="text-muted fw-medium">Loading schedule data...</div>
        </div>
    </div>

    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <div class="schedule-container">
                    <!-- Header Controls -->
                    <div class="header-controls">
                        <div class="row align-items-center">
                            <div class="col-md-6">
                                <div class="d-flex align-items-center mb-3">
                                    <div class="bg-gradient-primary rounded-circle p-3 me-3 shadow-sm" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                                        <i class="fas fa-calendar-check text-white fa-lg"></i>
                                    </div>
                                    <div>
                                        <h2 class="h3 mb-1 fw-bold" style="color: #1e293b;">
                                            Unaki Appointment Booking
                                        </h2>
                                        <p class="text-muted mb-0 fw-medium">
                                            <i class="fas fa-hand-pointer me-2 text-primary"></i>
                                            Drag to select time slots and create appointments
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6 text-end">
                                <div class="row g-3 justify-content-end">
                                    <div class="col-auto">
                                        <label class="form-label mb-2 d-block text-start fw-semibold">
                                            <i class="fas fa-calendar-day me-2 text-primary"></i>Select Date:
                                        </label>
                                        <div class="position-relative">
                                            <input type="date" id="scheduleDate" class="form-control ps-5" onchange="showLoadingAndLoad()">
                                            <i class="fas fa-calendar-alt position-absolute top-50 translate-middle-y ms-3 text-muted"></i>
                                        </div>
                                    </div>
                                    <div class="col-auto d-flex align-items-end gap-2">
                                        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#bookingModal" title="Book New Appointment">
                                            <i class="fas fa-calendar-plus me-2"></i>
                                            <span class="d-none d-sm-inline">Book Appointment</span>
                                        </button>
                                        <button class="btn btn-outline-secondary" onclick="showLoadingAndRefresh()" title="Refresh Schedule">
                                            <i class="fas fa-sync-alt me-2"></i>
                                            <span class="d-none d-md-inline">Refresh</span>
                                        </button>
                                        <button onclick="loadSampleData()" class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold hover:from-blue-600 hover:to-purple-700 transition-all duration-300 shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                                            <i class="fas fa-database mr-2"></i>
                                            Load Sample Data
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Stats Row -->
                    <div class="stats-row">
                        <div class="row">
                            <div class="col-3">
                                <div class="stat-item">
                                    <div class="stat-number" id="totalAppointments">0</div>
                                    <div class="stat-label">Appointments</div>
                                </div>
                            </div>
                            <div class="col-3">
                                <div class="stat-item">
                                    <div class="stat-number" id="activeStaff">0</div>
                                    <div class="stat-label">Staff on Duty</div>
                                </div>
                            </div>
                            <div class="col-3">
                                <div class="stat-item">
                                    <div class="stat-number" id="availableSlots">0</div>
                                    <div class="stat-label">Available Slots</div>
                                </div>
                            </div>
                            <div class="col-3">
                                <div class="stat-item">
                                    <div class="stat-number" id="utilizationRate">0%</div>
                                    <div class="stat-label">Utilization</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Schedule Grid -->
                    <div style="overflow-x: auto; padding-bottom: 10px;">
                        <div id="scheduleGrid" class="schedule-grid" style="min-width: 2220px;">
                            <!-- Grid content will be generated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Booking Modal -->
    <div class="modal fade" id="bookingModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="fas fa-calendar-plus me-2"></i>
                        New Appointment
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="bookingForm">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label">Client *</label>
                                    <select id="clientSelect" class="form-select" required>
                                        <option value="">Select Client</option>
                                        <!-- Clients will be populated from database -->
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label">Client Name (Manual Entry)</label>
                                    <input type="text" id="clientName" class="form-control" placeholder="Or enter new client name">
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label">Phone</label>
                                    <input type="tel" id="clientPhone" class="form-control">
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label">Email</label>
                                    <input type="email" id="clientEmail" class="form-control">
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label">Service *</label>
                                    <select id="serviceType" class="form-select" required>
                                        <option value="">Select Service</option>
                                        <!-- Services will be populated from database -->
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label">Staff *</label>
                                    <select id="staffSelect" class="form-select" required></select>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label class="form-label">Start Time *</label>
                                    <input type="time" id="startTime" class="form-control" required onchange="updateEndTime()" placeholder="Select or type time">
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label class="form-label">Duration *</label>
                                    <select id="appointmentDuration" class="form-select" required onchange="updateEndTime()">
                                        <option value="15">15 minutes</option>
                                        <option value="30">30 minutes</option>
                                        <option value="45">45 minutes</option>
                                        <option value="60" selected>1 hour</option>
                                        <option value="75">1 hour 15 minutes</option>
                                        <option value="90">1 hour 30 minutes</option>
                                        <option value="120">2 hours</option>
                                        <option value="150">2 hours 30 minutes</option>
                                        <option value="180">3 hours</option>
                                        <option value="240">4 hours</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label class="form-label">End Time *</label>
                                    <input type="text" id="endTime" class="form-control" required readonly placeholder="Auto-calculated">
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Notes</label>
                            <textarea id="appointmentNotes" class="form-control" rows="2"></textarea>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="bookAppointment()">Book Appointment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        let scheduleData = {
            staff: [],
            appointments: [],
            breaks: []
        };

        let isDragging = false;
        let dragStart = null;
        let dragSelection = null;
        let currentDate = new Date().toISOString().split('T')[0];

        // Loading overlay functions
        function showLoading() {
            document.getElementById('loadingOverlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('show');
        }

        function showLoadingAndLoad() {
            showLoading();
            setTimeout(() => {
                loadScheduleForDate();
                hideLoading();
            }, 800);
        }

        function showLoadingAndRefresh() {
            showLoading();
            setTimeout(() => {
                refreshSchedule();
                hideLoading();
            }, 600);
        }

        function showLoadingAndLoadSample() {
            showLoading();
            setTimeout(() => {
                loadSampleData();
                hideLoading();
            }, 1000);
        }

        // Add alias for compatibility
        window.showLoadingAndLoadSample = showLoadingAndLoadSample;

        // Quick booking modal function
        function openQuickBookingModal() {
            // Reset the booking modal form
            const form = document.getElementById('bookingForm');
            if (form) {
                form.reset();
            }

            // Clear selections
            document.getElementById('staffSelect').selectedIndex = 0;
            document.getElementById('clientSelect').selectedIndex = 0;
            document.getElementById('appointmentDuration').value = '60';
            
            // Reset client fields
            document.getElementById('clientName').placeholder = 'Or enter new client name';
            document.getElementById('clientPhone').value = '';
            document.getElementById('clientEmail').value = '';

            // Set default times (current time rounded to next hour)
            const now = new Date();
            const nextHour = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours() + 1, 0);
            const timeString = nextHour.toTimeString().slice(0, 5);

            // Set the time input to the calculated time
            const startTimeInput = document.getElementById('startTime');
            startTimeInput.value = timeString;
            updateEndTime(); // This will set the end time based on duration

            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('bookingModal'));
            modal.show();

            // Focus on client name field
            setTimeout(() => {
                document.getElementById('clientName').focus();
            }, 500);
        }

        // Make function globally available
        window.openQuickBookingModal = openQuickBookingModal;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            showLoading();
            document.getElementById('scheduleDate').value = currentDate;

            // Load initial data
            Promise.all([
                loadScheduleForDate(),
                loadServices(),
                loadStaff(),
                loadClients()
            ]).then(() => {
                hideLoading();
            }).catch(error => {
                console.error('Error loading initial data:', error);
                hideLoading();
            });

            // Add event listener for start time changes (already handled in onchange attribute)
        });

        function loadServices() {
            return fetch('/api/unaki/services')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(services => {
                    console.log('Loaded services:', Array.isArray(services) ? services.length : 'Invalid data');
                    
                    // Populate services dropdown
                    const serviceSelect = document.getElementById('serviceType');
                    if (serviceSelect && Array.isArray(services)) {
                        serviceSelect.innerHTML = '<option value="">Select Service</option>';
                        
                        // Group services by category
                        const servicesByCategory = {};
                        services.forEach(service => {
                            const category = service.category || 'General';
                            if (!servicesByCategory[category]) {
                                servicesByCategory[category] = [];
                            }
                            servicesByCategory[category].push(service);
                        });
                        
                        // Create optgroups for each category
                        Object.keys(servicesByCategory).sort().forEach(category => {
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = category;
                            
                            servicesByCategory[category].forEach(service => {
                                const option = document.createElement('option');
                                option.value = service.name;
                                option.textContent = `${service.name} (${service.duration} min)`;
                                option.dataset.serviceId = service.id;
                                option.dataset.duration = service.duration;
                                option.dataset.price = service.price;
                                optgroup.appendChild(option);
                            });
                            
                            serviceSelect.appendChild(optgroup);
                        });
                        
                        // Add event listener to auto-update duration when service changes
                        serviceSelect.addEventListener('change', function() {
                            const selectedOption = this.options[this.selectedIndex];
                            if (selectedOption && selectedOption.dataset.duration) {
                                const durationSelect = document.getElementById('appointmentDuration');
                                if (durationSelect) {
                                    durationSelect.value = selectedOption.dataset.duration;
                                    updateEndTime();
                                }
                            }
                        });
                    }
                    
                    return services;
                })
                .catch(error => {
                    console.error('Failed to load services:', error);
                    return [];
                });
        }

        function loadStaff() {
            return fetch('/api/unaki/staff')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(staff => {
                    console.log('Loaded staff:', Array.isArray(staff) ? staff.length : 'Invalid data');
                    // Update staff select in modal
                    const staffSelect = document.getElementById('staffSelect');
                    if (staffSelect && Array.isArray(staff)) {
                        staffSelect.innerHTML = '<option value="">Select Staff</option>';
                        staff.forEach(member => {
                            const option = document.createElement('option');
                            option.value = member.id;
                            option.textContent = `${member.name} (${member.specialty || member.role || 'Staff'})`;
                            staffSelect.appendChild(option);
                        });
                    }
                    return staff;
                })
                .catch(error => {
                    console.error('Failed to load staff:', error);
                    return [];
                });
        }

        function loadClients() {
            return fetch('/api/unaki/clients')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(clients => {
                    console.log('Loaded clients:', Array.isArray(clients) ? clients.length : 'Invalid data');
                    
                    // Populate clients dropdown
                    const clientSelect = document.getElementById('clientSelect');
                    if (clientSelect && Array.isArray(clients)) {
                        clientSelect.innerHTML = '<option value="">Select Client</option>';
                        
                        clients.forEach(client => {
                            const option = document.createElement('option');
                            option.value = client.id;
                            option.textContent = `${client.name}`;
                            option.dataset.phone = client.phone || '';
                            option.dataset.email = client.email || '';
                            clientSelect.appendChild(option);
                        });
                        
                        // Add event listener to auto-fill client details when client is selected
                        clientSelect.addEventListener('change', function() {
                            const selectedOption = this.options[this.selectedIndex];
                            if (selectedOption && selectedOption.value) {
                                // Fill in client details
                                document.getElementById('clientName').value = selectedOption.textContent;
                                document.getElementById('clientPhone').value = selectedOption.dataset.phone || '';
                                document.getElementById('clientEmail').value = selectedOption.dataset.email || '';
                                
                                // Clear manual entry when selecting from dropdown
                                document.getElementById('clientName').placeholder = 'Selected: ' + selectedOption.textContent;
                            } else {
                                // Clear fields when no client selected
                                document.getElementById('clientName').value = '';
                                document.getElementById('clientPhone').value = '';
                                document.getElementById('clientEmail').value = '';
                                document.getElementById('clientName').placeholder = 'Or enter new client name';
                            }
                        });
                    }
                    
                    return clients;
                })
                .catch(error => {
                    console.error('Failed to load clients:', error);
                    return [];
                });
        }

        function generateTimeSlots() {
            const slots = [];
            for (let hour = 8; hour < 16; hour++) {
                const timeStr = `${hour.toString().padStart(2, '0')}:00`;
                let displayTime;
                if (hour <= 12) {
                    displayTime = `${hour}:00 AM`;
                } else {
                    displayTime = `${hour - 12}:00 PM`;
                }
                if (hour === 12) {
                    displayTime = '12:00 PM';
                }
                slots.push({ time: timeStr, display: displayTime });
            }
            return slots;
        }

        function loadScheduleForDate() {
            currentDate = document.getElementById('scheduleDate').value;
            console.log('Loading schedule for date:', currentDate);

            // Load from API
            fetch(`/api/unaki/schedule?date=${currentDate}`)
                .then(response => {
                    console.log('Schedule API response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text(); // Get as text first
                })
                .then(text => {
                    console.log('Schedule API raw response:', text.substring(0, 200) + '...');
                    try {
                        const data = JSON.parse(text);
                        if (data.success) {
                            scheduleData = {
                                staff: data.staff || [],
                                appointments: data.appointments || [],
                                breaks: data.breaks || []
                            };
                            console.log('Schedule data loaded:', scheduleData);
                        } else {
                            console.error('Failed to load schedule:', data.error);
                            scheduleData = { staff: [], appointments: [], breaks: [] };
                        }
                    } catch (parseError) {
                        console.error('JSON parse error:', parseError);
                        scheduleData = { staff: [], appointments: [], breaks: [] };
                    }
                    renderSchedule();
                    updateStats();
                })
                .catch(error => {
                    console.error('Error loading schedule:', error);
                    scheduleData = { staff: [], appointments: [], breaks: [] };
                    renderSchedule();
                    updateStats();
                });
        }

        function loadSampleData() {
            console.log('Loading sample data...');
            fetch('/api/unaki/load-sample-data', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})
            })
            .then(response => {
                console.log('Sample data API response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.text(); // Get as text first
            })
            .then(text => {
                console.log('Sample data API raw response:', text.substring(0, 200) + '...');
                try {
                    const data = JSON.parse(text);
                    if (data.success) {
                        console.log('Sample data loaded:', data.message);
                        // Reload the schedule to show new data
                        loadScheduleForDate();
                    } else {
                        console.error('Failed to load sample data:', data.error);
                        // Fallback to hardcoded data
                        loadHardcodedSampleData();
                    }
                } catch (parseError) {
                    console.error('JSON parse error in sample data:', parseError);
                    loadHardcodedSampleData();
                }
            })
            .catch(error => {
                console.error('Error loading sample data:', error);
                loadHardcodedSampleData();
            });
        }

        function loadHardcodedSampleData() {
            scheduleData = {
                        staff: [
                            { id: 1, name: 'Sarah Johnson', role: 'Senior Facial Specialist' },
                            { id: 2, name: 'Michael Chen', role: 'Massage Therapist' },
                            { id: 3, name: 'Emily Rodriguez', role: 'Hair Stylist & Colorist' },
                            { id: 4, name: 'James Wilson', role: 'Nail Technician' },
                            { id: 5, name: 'Linda Davis', role: 'Makeup Artist' },
                            { id: 6, name: 'Priya Sharma', role: 'Ayurvedic Therapist' },
                            { id: 7, name: 'Alex Thompson', role: 'Body Treatment Specialist' },
                            { id: 8, name: 'Maria Santos', role: 'Waxing Specialist' }
                        ],
                appointments: [
                    // Morning rush (8:00-10:00)
                    { id: 1, staffId: 1, clientName: 'Jessica Brown', service: 'Deep Cleansing Facial', startTime: '08:00', endTime: '09:30', duration: 90 },
                    { id: 2, staffId: 2, clientName: 'Amanda White', service: 'Hot Stone Massage', startTime: '08:30', endTime: '10:00', duration: 90 },
                    { id: 3, staffId: 3, clientName: 'Rachel Green', service: 'Hair Wash & Blow Dry', startTime: '08:15', endTime: '09:00', duration: 45 },
                    { id: 4, staffId: 4, clientName: 'Robert Taylor', service: 'Express Manicure', startTime: '08:00', endTime: '08:45', duration: 45 },
                    { id: 5, staffId: 6, clientName: 'Ananya Patel', service: 'Abhyanga Massage', startTime: '08:00', endTime: '09:30', duration: 90 },
                    { id: 6, staffId: 7, clientName: 'Catherine Moore', service: 'Body Scrub', startTime: '08:30', endTime: '10:00', duration: 90 },

                    // Mid-morning (10:00-12:00)
                    { id: 7, staffId: 1, clientName: 'Emma Thompson', service: 'Anti-Aging Facial', startTime: '10:00', endTime: '11:30', duration: 90 },
                    { id: 8, staffId: 2, clientName: 'David Brown', service: 'Swedish Massage', startTime: '10:30', endTime: '11:30', duration: 60 },
                    { id: 9, staffId: 3, clientName: 'Sophie Miller', service: 'Hair Cut & Style', startTime: '09:30', endTime: '10:45', duration: 75 },
                    { id: 10, staffId: 4, clientName: 'Lisa Anderson', service: 'Gel Manicure', startTime: '09:15', endTime: '10:15', duration: 60 },
                    { id: 11, staffId: 5, clientName: 'Kate Wilson', service: 'Bridal Makeup Trial', startTime: '10:00', endTime: '12:00', duration: 120 },
                    { id: 12, staffId: 6, clientName: 'Meera Gupta', service: 'Shirodhara Treatment', startTime: '10:00', endTime: '11:00', duration: 60 },
                    { id: 13, staffId: 7, clientName: 'Jennifer Davis', service: 'Cellulite Treatment', startTime: '10:30', endTime: '11:30', duration: 60 },
                    { id: 14, staffId: 8, clientName: 'Hannah White', service: 'Full Leg Wax', startTime: '10:00', endTime: '10:45', duration: 45 },

                    // Afternoon (13:00-15:00)
                    { id: 15, staffId: 1, clientName: 'Victoria James', service: 'Hydrating Facial', startTime: '13:00', endTime: '14:00', duration: 60 },
                    { id: 16, staffId: 2, clientName: 'Mark Johnson', service: 'Deep Tissue Massage', startTime: '13:30', endTime: '15:00', duration: 90 },
                    { id: 17, staffId: 3, clientName: 'Maria Garcia', service: 'Hair Color & Highlights', startTime: '13:00', endTime: '15:30', duration: 150 },
                    { id: 18, staffId: 4, clientName: 'Sarah Connor', service: 'Spa Pedicure', startTime: '13:00', endTime: '14:00', duration: 60 },
                    { id: 19, staffId: 6, clientName: 'Ravi Kumar', service: 'Marma Point Therapy', startTime: '13:00', endTime: '14:00', duration: 60 },
                    { id: 20, staffId: 7, clientName: 'Michelle Obama', service: 'Body Wrap Treatment', startTime: '13:30', endTime: '15:00', duration: 90 },
                    { id: 21, staffId: 8, clientName: 'Taylor Swift', service: 'Brazilian Wax', startTime: '13:15', endTime: '14:00', duration: 45 },

                    // Late afternoon (15:00-16:00)
                    { id: 22, staffId: 1, clientName: 'Grace Kelly', service: 'Express Facial', startTime: '14:30', endTime: '15:15', duration: 45 },
                    { id: 23, staffId: 2, clientName: 'Chris Evans', service: 'Sports Massage', startTime: '15:30', endTime: '16:30', duration: 60 },
                    { id: 24, staffId: 4, clientName: 'Natalie Portman', service: 'French Manicure', startTime: '14:30', endTime: '15:15', duration: 45 },
                    { id: 25, staffId: 5, clientName: 'Scarlett Johansson', service: 'Evening Makeup', startTime: '15:00', endTime: '16:00', duration: 60 },
                    { id: 26, staffId: 6, clientName: 'Deepika Singh', service: 'Ayurvedic Consultation', startTime: '14:30', endTime: '15:00', duration: 30 },
                    { id: 27, staffId: 8, clientName: 'Emma Watson', service: 'Eyebrow Threading', startTime: '15:00', endTime: '15:15', duration: 15 }
                ],
                breaks: [
                    // Lunch breaks
                    { id: 1, staffId: 1, startTime: '12:00', endTime: '13:00', reason: 'Lunch Break' },
                    { id: 2, staffId: 2, startTime: '12:30', endTime: '13:30', reason: 'Lunch Break' },
                    { id: 3, staffId: 3, startTime: '11:30', endTime: '12:30', reason: 'Lunch Break' },
                    { id: 4, staffId: 4, startTime: '12:00', endTime: '13:00', reason: 'Lunch Break' },
                    { id: 5, staffId: 5, startTime: '12:30', endTime: '13:30', reason: 'Lunch Break' },
                    { id: 6, staffId: 6, startTime: '12:00', endTime: '13:00', reason: 'Lunch Break' },
                    { id: 7, staffId: 7, startTime: '12:30', endTime: '13:30', reason: 'Lunch Break' },
                    { id: 8, staffId: 8, startTime: '12:00', endTime: '13:00', reason: 'Lunch Break' },

                    // Short breaks
                    { id: 9, staffId: 2, startTime: '11:30', endTime: '11:45', reason: 'Coffee Break' },
                    { id: 10, staffId: 4, startTime: '10:15', endTime: '10:30', reason: 'Equipment Setup' },
                    { id: 11, staffId: 5, startTime: '14:00', endTime: '14:15', reason: 'Coffee Break' },
                    { id: 12, staffId: 7, startTime: '11:30', endTime: '11:45', reason: 'Equipment Cleaning' },
                    { id: 13, staffId: 8, startTime: '14:00', endTime: '14:15', reason: 'Coffee Break' }
                ]
            };

            // Save to localStorage
            localStorage.setItem(`schedule-${currentDate}`, JSON.stringify(scheduleData));

            renderSchedule();
            updateStats();
        }

        // Add context menu for appointments
        function showAppointmentContextMenu(e, appointment) {
            e.preventDefault();
            e.stopPropagation();

            // Remove any existing context menu
            const existingMenu = document.querySelector('.appointment-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            const contextMenu = document.createElement('div');
            contextMenu.className = 'appointment-context-menu position-absolute bg-white border rounded shadow-lg p-2';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            contextMenu.style.zIndex = '1000';
            contextMenu.style.minWidth = '150px';

            contextMenu.innerHTML = `
                <div class="btn btn-sm btn-outline-primary d-block mb-1" onclick="viewAppointment(${appointment.id})">
                    <i class="fas fa-eye me-2"></i>View Details
                </div>
                <div class="btn btn-sm btn-outline-warning d-block mb-1" onclick="editAppointment(${appointment.id})">
                    <i class="fas fa-edit me-2"></i>Edit
                </div>
                <div class="btn btn-sm btn-outline-danger d-block" onclick="cancelAppointment(${appointment.id})">
                    <i class="fas fa-times me-2"></i>Cancel
                </div>
            `;

            document.body.appendChild(contextMenu);

            // Remove context menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', function removeMenu() {
                    contextMenu.remove();
                    document.removeEventListener('click', removeMenu);
                });
            }, 10);
        }

        function renderSchedule() {
            const grid = document.getElementById('scheduleGrid');
            const timeSlots = generateTimeSlots();

            // Clear grid
            grid.innerHTML = '';

            // Create header row
            const emptyCorner = document.createElement('div');
            emptyCorner.className = 'time-header';
            emptyCorner.innerHTML = '<strong>Staff</strong>';
            grid.appendChild(emptyCorner);

            timeSlots.forEach(slot => {
                const timeHeader = document.createElement('div');
                timeHeader.className = 'time-header';
                timeHeader.textContent = slot.display;
                grid.appendChild(timeHeader);
            });

            // Create staff rows
            scheduleData.staff.forEach(staff => {
                // Staff name cell
                const staffCell = document.createElement('div');
                staffCell.className = 'staff-cell';
                staffCell.innerHTML = `
                    <div class="staff-name">${staff.name}</div>
                    <div class="staff-role">${staff.role}</div>
                `;
                grid.appendChild(staffCell);

                // Time slots for this staff member
                timeSlots.forEach((slot, slotIndex) => {
                    const timeSlot = document.createElement('div');
                    timeSlot.className = 'time-slot';
                    timeSlot.dataset.staffId = staff.id;
                    timeSlot.dataset.time = slot.time;

                    // Check for appointments that start at this time
                    const appointment = scheduleData.appointments.find(apt => 
                        apt.staffId === staff.id && apt.startTime === slot.time
                    );

                    // Check if this slot is occupied by an ongoing appointment
                    const ongoingAppointment = scheduleData.appointments.find(apt => {
                        if (apt.staffId !== staff.id) return false;

                        const aptStartHour = parseInt(apt.startTime.split(':')[0]);
                        const aptStartMinute = parseInt(apt.startTime.split(':')[1]);
                        const aptEndHour = parseInt(apt.endTime.split(':')[0]);
                        const aptEndMinute = parseInt(apt.endTime.split(':')[1]);

                        const slotHour = parseInt(slot.time.split(':')[0]);
                        const slotMinute = parseInt(slot.time.split(':')[1]);

                        const aptStartTime = aptStartHour * 60 + aptStartMinute;
                        const aptEndTime = aptEndHour * 60 + aptEndMinute;
                        const slotTime = slotHour * 60 + slotMinute;

                        return slotTime >= aptStartTime && slotTime < aptEndTime;
                    });

                    // Check for breaks that start at this time
                    const breakItem = scheduleData.breaks.find(brk => 
                        brk.staffId === staff.id && brk.startTime === slot.time
                    );

                    // Check if this slot is occupied by an ongoing break
                    const ongoingBreak = scheduleData.breaks.find(brk => {
                        if (brk.staffId !== staff.id) return false;

                        const brkStartHour = parseInt(brk.startTime.split(':')[0]);
                        const brkStartMinute = parseInt(brk.startTime.split(':')[1]);
                        const brkEndHour = parseInt(brk.endTime.split(':')[0]);
                        const brkEndMinute = parseInt(brk.endTime.split(':')[1]);

                        const slotHour = parseInt(slot.time.split(':')[0]);
                        const slotMinute = parseInt(slot.time.split(':')[1]);

                        const brkStartTime = brkStartHour * 60 + brkStartMinute;
                        const brkEndTime = brkEndHour * 60 + brkEndMinute;
                        const slotTime = slotHour * 60 + slotMinute;

                        return slotTime >= brkStartTime && slotTime < brkEndTime;
                    });

                    if (appointment) {
                        // Calculate span based on duration
                        const duration = appointment.duration || 60;
                        const durationText = duration >= 60 ? 
                            `${Math.floor(duration / 60)}h ${duration % 60 > 0 ? duration % 60 + 'm' : ''}`.trim() :
                            `${duration}m`;

                        // Calculate the actual width based on exact duration in minutes
                        // Each time slot represents 60 minutes, so calculate percentage
                        let blockWidth = '100%';

                        if (duration <= 60) {
                            // For appointments 60 minutes or less, calculate percentage of current slot
                            const widthPercentage = (duration / 60) * 100;
                            blockWidth = `${widthPercentage}%`;
                        } else {
                            // For appointments longer than 60 minutes, span multiple slots
                            const fullSlots = Math.floor(duration / 60);
                            const remainingMinutes = duration % 60;
                            const remainingPercentage = remainingMinutes > 0 ? (remainingMinutes / 60) * 100 : 0;

                            if (remainingMinutes === 0) {
                                // Exact hour appointments (90min = 1.5 slots, 120min = 2 slots)
                                blockWidth = `calc(${fullSlots * 100}% + ${(fullSlots - 1)}px)`;
                            } else {
                                // Appointments with partial minutes (90min, 150min, etc.)
                                blockWidth = `calc(${(fullSlots * 100) + remainingPercentage}% + ${fullSlots}px)`;
                            }
                        }

                        const appointmentBlock = document.createElement('div');
                        appointmentBlock.className = 'appointment-block';
                        appointmentBlock.style.width = blockWidth;
                        appointmentBlock.style.zIndex = '10';
                        appointmentBlock.style.position = 'absolute';
                        appointmentBlock.style.top = '1px';
                        appointmentBlock.style.left = '1px';
                        appointmentBlock.style.height = 'calc(100% - 2px)';

                        appointmentBlock.innerHTML = `
                            <div class="appointment-client" title="${appointment.clientName}">${appointment.clientName}</div>
                            <div class="appointment-service" title="${appointment.service}">${appointment.service}</div>
                            <div style="margin-top: auto;">
                                <div class="appointment-time">${appointment.startTime} - ${appointment.endTime}</div>
                                <div class="appointment-duration">${durationText}</div>
                            </div>
                        `;

                        // Add right-click context menu
                        appointmentBlock.addEventListener('contextmenu', (e) => {
                            showAppointmentContextMenu(e, appointment);
                        });

                        timeSlot.appendChild(appointmentBlock);

                        // Mark the time slot as having a starting appointment
                        timeSlot.dataset.hasAppointment = 'start';

                    } else if (ongoingAppointment && !appointment) {
                        // This slot is part of an ongoing appointment - make it invisible but blocked
                        timeSlot.innerHTML = `
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: transparent; cursor: not-allowed;"></div>
                        `;
                        timeSlot.dataset.hasAppointment = 'ongoing';
                        timeSlot.style.background = '#f8f9fa';
                        timeSlot.style.borderTop = 'none';

                    } else if (breakItem) {
                        // Calculate break duration for spanning
                        const brkStartHour = parseInt(breakItem.startTime.split(':')[0]);
                        const brkStartMinute = parseInt(breakItem.startTime.split(':')[1]);
                        const brkEndHour = parseInt(breakItem.endTime.split(':')[0]);
                        const brkEndMinute = parseInt(breakItem.endTime.split(':')[1]);

                        const brkStartTime = brkStartHour * 60 + brkStartMinute;
                        const brkEndTime = brkEndHour * 60 + brkEndMinute;
                        const breakDuration = brkEndTime - brkStartTime;

                        // Calculate the actual width based on exact break duration in minutes
                        let breakWidth = '100%';

                        if (breakDuration <= 60) {
                            // For breaks 60 minutes or less, calculate percentage of current slot
                            const widthPercentage = (breakDuration / 60) * 100;
                            breakWidth = `${widthPercentage}%`;
                        } else {
                            // For breaks longer than 60 minutes, span multiple slots
                            const fullSlots = Math.floor(breakDuration / 60);
                            const remainingMinutes = breakDuration % 60;
                            const remainingPercentage = remainingMinutes > 0 ? (remainingMinutes / 60) * 100 : 0;

                            if (breakDuration === 0) { // Handle zero duration breaks
                                breakWidth = '0%';
                            } else if (breakDuration === 60) { // Handle exactly 60 min breaks
                                breakWidth = '100%';
                            } else if (remainingMinutes === 0) {
                                // Exact hour breaks
                                breakWidth = `calc(${fullSlots * 100}% + ${(fullSlots - 1)}px)`;
                            } else {
                                // Breaks with partial minutes
                                breakWidth = `calc(${(fullSlots * 100) + remainingPercentage}% + ${fullSlots}px)`;
                            }
                        }

                        timeSlot.innerHTML = `
                            <div class="break-block" style="width: ${breakWidth}; z-index: 10; position: absolute; top: 1px; left: 1px; height: calc(100% - 2px);">
                                <div style="font-size: 10px;"><i class="fas fa-coffee me-1"></i>Break</div>
                                <div class="break-time" style="font-size: 8px; opacity: 0.9; margin-top: 2px;">${breakItem.startTime} - ${breakItem.endTime}</div>
                            </div>
                        `;
                        timeSlot.dataset.hasBreak = 'start';

                    } else if (ongoingBreak && !breakItem) {
                        // This slot is part of an ongoing break - make it invisible but blocked
                        timeSlot.innerHTML = `
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: transparent; cursor: not-allowed;"></div>
                        `;
                        timeSlot.dataset.hasBreak = 'ongoing';
                        timeSlot.style.background = '#fff3cd';
                        timeSlot.style.borderTop = 'none';
                    }

                    grid.appendChild(timeSlot);
                });
            });

            setupDragHandlers();
        }

        function setupDragHandlers() {
            const timeSlots = document.querySelectorAll('.time-slot');

            timeSlots.forEach(slot => {
                slot.addEventListener('mousedown', handleMouseDown);
                slot.addEventListener('mouseenter', handleMouseEnter);
                slot.addEventListener('mouseup', handleMouseUp);
            });
        }

        function handleMouseDown(e) {
            // Prevent drag from starting if clicking on an existing appointment or break
            if (e.target.closest('.appointment-block, .break-block')) {
                // Optionally, you can open the modal for existing appointments here
                // For now, we just prevent dragging
                return;
            }

            // Prevent drag from starting if clicking on the drag-selection overlay itself
            if (e.target.classList.contains('drag-selection')) {
                return;
            }

            // Prevent default browser drag behavior
            e.preventDefault();

            isDragging = true;
            dragStart = {
                staffId: parseInt(e.currentTarget.dataset.staffId),
                time: e.currentTarget.dataset.time,
                element: e.currentTarget
            };

            // Create a visual indicator for dragging
            dragSelection = document.createElement('div');
            dragSelection.className = 'drag-selection';
            dragSelection.style.left = `${e.currentTarget.offsetLeft}px`;
            dragSelection.style.top = `${e.currentTarget.offsetTop}px`;
            dragSelection.style.width = `${e.currentTarget.offsetWidth}px`;
            dragSelection.style.height = `${e.currentTarget.offsetHeight}px`;
            e.currentTarget.parentNode.appendChild(dragSelection); // Append to the parent of the grid for correct positioning

            // Mark the starting slot as being dragged
            e.currentTarget.style.backgroundColor = 'rgba(37, 99, 235, 0.1)'; // Visual feedback for the start slot
        }

        function handleMouseEnter(e) {
            if (!isDragging) return;

            // Ensure we are only dragging within the same staff member's row
            const currentStaffId = parseInt(e.currentTarget.dataset.staffId);
            if (currentStaffId !== dragStart.staffId) return;

            // Prevent drag into slots that already have content or are breaks
            if (e.currentTarget.dataset.hasAppointment === 'start' || e.currentTarget.dataset.hasAppointment === 'ongoing' ||
                e.currentTarget.dataset.hasBreak === 'start' || e.currentTarget.dataset.hasBreak === 'ongoing') {
                return;
            }

            // Highlight selection dynamically
            const startIndex = Array.from(e.currentTarget.parentNode.children).indexOf(dragStart.element);
            const endIndex = Array.from(e.currentTarget.parentNode.children).indexOf(e.currentTarget);

            // Determine the start and end of the selection range
            const start = Math.min(startIndex, endIndex);
            const end = Math.max(startIndex, endIndex);

            // Update drag selection size and position
            const startElement = e.currentTarget.parentNode.children[start];
            const endElement = e.currentTarget.parentNode.children[end];

            dragSelection.style.left = `${startElement.offsetLeft}px`;
            dragSelection.style.width = `${endElement.offsetLeft + endElement.offsetWidth - startElement.offsetLeft}px`;
            dragSelection.style.top = `${startElement.offsetTop}px`; // Ensure it's aligned with the row
            dragSelection.style.height = `${startElement.offsetHeight}px`; // Match the height of a single slot

            // Add visual feedback to all selected slots
            for (let i = start; i <= end; i++) {
                const slot = e.currentTarget.parentNode.children[i];
                if (slot.classList.contains('time-slot')) {
                    slot.style.backgroundColor = 'rgba(37, 99, 235, 0.1)';
                }
            }
        }


        function handleMouseUp(e) {
            if (!isDragging) return;

            isDragging = false;

            // Remove the drag selection indicator
            if (dragSelection && dragSelection.parentNode) {
                dragSelection.parentNode.removeChild(dragSelection);
            }

            const endTime = e.currentTarget.dataset.time;
            const staffId = dragStart.staffId;

            // Clear any lingering background highlights
            document.querySelectorAll('.time-slot').forEach(slot => {
                slot.style.backgroundColor = '';
            });

            // Ensure a valid selection was made (start and end times are different, and valid staffId)
            if (staffId && dragStart.time && endTime && dragStart.time !== endTime) {
                openBookingModal(staffId, dragStart.time, endTime);
            } else if (staffId && dragStart.time && endTime && dragStart.time === endTime) {
                // If only one slot was clicked, open modal for that slot
                openBookingModal(staffId, dragStart.time, dragStart.element.dataset.time);
            }

            // Reset drag state
            dragStart = null;
            dragSelection = null;
        }

        function openBookingModal(staffId, startTime, endTime) {
            const staff = scheduleData.staff.find(s => s.id === staffId);
            if (!staff) {
                console.error("Staff not found for ID:", staffId);
                return;
            }

            // Set start time in the input
            const startTimeInput = document.getElementById('startTime');
            startTimeInput.value = startTime;
            
            // Set end time display (convert to 12-hour format if needed)
            const endTimeInput = document.getElementById('endTime');
            if (endTime) {
                const [endHours, endMinutes] = endTime.split(':').map(Number);
                endTimeInput.value = convertTo12HourFormat(endHours, endMinutes);
            }

            // Populate staff select
            const staffSelect = document.getElementById('staffSelect');
            staffSelect.innerHTML = ''; // Clear existing options
            scheduleData.staff.forEach(s => {
                const option = document.createElement('option');
                option.value = s.id;
                option.textContent = `${s.name} (${s.role})`;
                if (s.id === staffId) {
                    option.selected = true;
                }
                staffSelect.appendChild(option);
            });

            // Calculate duration based on selected time slots
            const startMinutes = parseInt(startTime.split(':')[0]) * 60 + parseInt(startTime.split(':')[1]);
            const endMinutes = parseInt(endTime.split(':')[0]) * 60 + parseInt(endTime.split(':')[1]);
            const duration = endMinutes - startMinutes;

            // Set the duration in the modal's select element
            const durationSelect = document.getElementById('appointmentDuration');
            if (durationSelect) {
                durationSelect.value = duration;
                updateEndTime(); // Update end time based on selected duration
            }

            const modalElement = document.getElementById('bookingModal');
            const modal = new bootstrap.Modal(modalElement);
            modal.show();
        }

        function updateEndTime() {
            const startTimeInput = document.getElementById('startTime');
            const durationSelect = document.getElementById('appointmentDuration');
            const endTimeInput = document.getElementById('endTime');

            const startTime = startTimeInput.value;
            const duration = parseInt(durationSelect.value);

            if (startTime && !isNaN(duration)) {
                const [hours, minutes] = startTime.split(':').map(Number);
                const startTotalMinutes = hours * 60 + minutes;
                const endTotalMinutes = startTotalMinutes + duration;

                const endHours = Math.floor(endTotalMinutes / 60);
                const endMins = endTotalMinutes % 60;

                // Convert to 12-hour format for display
                const displayEndTime = convertTo12HourFormat(endHours, endMins);
                endTimeInput.value = displayEndTime;
            } else if (startTime) {
                // If duration is not selected yet, just set end time based on start time and default duration if any
                const durationDefault = parseInt(durationSelect.value) || 60; // Default to 60 minutes if not set
                const [hours, minutes] = startTime.split(':').map(Number);
                const startTotalMinutes = hours * 60 + minutes;
                const endTotalMinutes = startTotalMinutes + durationDefault;
                const endHours = Math.floor(endTotalMinutes / 60);
                const endMins = endTotalMinutes % 60;
                const displayEndTime = convertTo12HourFormat(endHours, endMins);
                endTimeInput.value = displayEndTime;
            }
        }

        function convertTo12HourFormat(hours, minutes) {
            const displayHours = hours % 24; // Handle overflow past midnight
            const period = displayHours >= 12 ? 'PM' : 'AM';
            const hour12 = displayHours === 0 ? 12 : (displayHours > 12 ? displayHours - 12 : displayHours);
            return `${hour12}:${minutes.toString().padStart(2, '0')} ${period}`;
        }

        function bookAppointment() {
            const form = document.getElementById('bookingForm');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }

            const selectedStaffId = parseInt(document.getElementById('staffSelect').value);
            const selectedClientId = document.getElementById('clientSelect').value;
            const startTime = document.getElementById('startTime').value;
            const endTimeDisplay = document.getElementById('endTime').value;
            
            // Calculate actual end time in 24-hour format for backend
            const duration = parseInt(document.getElementById('appointmentDuration').value);
            const [startHours, startMinutes] = startTime.split(':').map(Number);
            const startTotalMinutes = startHours * 60 + startMinutes;
            const endTotalMinutes = startTotalMinutes + duration;
            const endHours = Math.floor(endTotalMinutes / 60);
            const endMins = endTotalMinutes % 60;
            const endTime = `${endHours.toString().padStart(2, '0')}:${endMins.toString().padStart(2, '0')}`;
            const clientName = document.getElementById('clientName').value.trim();
            const serviceType = document.getElementById('serviceType').value;

            // Enhanced validation - either select existing client or enter new client name
            if (!selectedClientId && !clientName) {
                alert('Please select an existing client or enter a new client name.');
                document.getElementById('clientSelect').focus();
                return;
            }

            if (!serviceType) {
                alert('Please select a service.');
                document.getElementById('serviceType').focus();
                return;
            }

            if (!startTime || !endTime || startTime >= endTime) {
                alert('Please ensure the start time is before the end time.');
                document.getElementById('startTime').focus();
                return;
            }

            if (isNaN(selectedStaffId) || selectedStaffId === 0) {
                alert('Please select a staff member.');
                document.getElementById('staffSelect').focus();
                return;
            }

            const appointmentData = {
                staffId: selectedStaffId,
                clientId: selectedClientId || null,
                clientName: clientName || document.getElementById('clientSelect').options[document.getElementById('clientSelect').selectedIndex].textContent,
                clientPhone: document.getElementById('clientPhone').value.trim(),
                clientEmail: document.getElementById('clientEmail').value.trim(),
                serviceType: serviceType,
                startTime: startTime,
                endTime: endTime,
                date: currentDate,
                notes: document.getElementById('appointmentNotes').value.trim()
            };

            console.log('Sending appointment data:', appointmentData);

            // Check for conflicts with existing appointments or breaks for the selected staff member and time
            const conflicts = scheduleData.appointments.some(apt =>
                apt.staffId === selectedStaffId &&
                ( (startTime >= apt.startTime && startTime < apt.endTime) ||
                  (endTime > apt.startTime && endTime <= apt.endTime) ||
                  (startTime <= apt.startTime && endTime >= apt.endTime) )
            ) || scheduleData.breaks.some(brk =>
                brk.staffId === selectedStaffId &&
                ( (startTime >= brk.startTime && startTime < brk.endTime) ||
                  (endTime > brk.startTime && endTime <= brk.endTime) ||
                  (startTime <= brk.startTime && endTime >= brk.endTime) )
            );

            if (conflicts) {
                alert('The selected time slot conflicts with an existing appointment or break for this staff member.');
                return;
            }

            showLoading(); // Show loading indicator before API call

            fetch('/api/unaki/create-appointment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(appointmentData)
            })
            .then(response => {
                console.log('Response status:', response.status);
                return response.text().then(text => {
                    console.log('Raw response:', text);
                    try {
                        return JSON.parse(text);
                    } catch (e) {
                        throw new Error('Invalid JSON response: ' + text.substring(0, 100));
                    }
                });
            })
            .then(data => {
                console.log('Parsed response:', data);

                if (data.success) {
                    console.log('Appointment created successfully:', data.appointmentId || data.booking?.id);

                    // Add the new appointment to the local scheduleData for immediate UI update
                    const newAppointment = {
                        id: data.appointmentId || data.booking?.id || 'temp_' + Date.now(),
                        staffId: appointmentData.staffId,
                        clientName: appointmentData.clientName,
                        service: appointmentData.serviceType,
                        startTime: appointmentData.startTime,
                        endTime: appointmentData.endTime,
                        duration: parseInt(document.getElementById('appointmentDuration').value),
                        status: 'confirmed'
                    };

                    scheduleData.appointments.push(newAppointment);
                    renderSchedule(); // Re-render to show the new appointment
                    updateStats();    // Update stats

                    // Reset form and close modal
                    form.reset();
                    const modalElement = document.getElementById('bookingModal');
                    const modal = bootstrap.Modal.getInstance(modalElement);
                    if (modal) {
                        modal.hide();
                    }

                    showNotification(`
                        🎉 <strong>Appointment Booked Successfully!</strong><br>
                        Client: ${appointmentData.clientName}<br>
                        Service: ${appointmentData.serviceType}<br>
                        Time: ${appointmentData.startTime} - ${appointmentData.endTime}
                    `, 'success', 4000);

                    // Reload schedule data to show updated information
                    setTimeout(() => {
                        loadScheduleForDate();
                    }, 1000);

                } else {
                    console.error('Booking failed:', data.error);
                    alert('Error creating appointment: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error booking appointment:', error);
                alert('Failed to book appointment. Error: ' + error.message);
            })
            .finally(() => {
                hideLoading(); // Hide loading indicator after API call
            });
        }

        function updateStats() {
            const totalAppointmentsElement = document.getElementById('totalAppointments');
            const activeStaffElement = document.getElementById('activeStaff');
            const availableSlotsElement = document.getElementById('availableSlots');
            const utilizationRateElement = document.getElementById('utilizationRate');

            if (totalAppointmentsElement) totalAppointmentsElement.textContent = scheduleData.appointments.length;
            if (activeStaffElement) activeStaffElement.textContent = scheduleData.staff.length;

            // Calculate total possible slots considering the operating hours (e.g., 8 AM to 4 PM = 8 hours)
            const operatingHours = 8; // 8 time slots from 8:00 to 15:00
            const totalPossibleSlots = scheduleData.staff.length * operatingHours;

            // Calculate currently booked slots (appointments + breaks)
            const bookedSlotsCount = scheduleData.appointments.length + scheduleData.breaks.length;

            const availableSlots = Math.max(0, totalPossibleSlots - bookedSlotsCount);
            const utilizationRate = totalPossibleSlots > 0 ? Math.round((bookedSlotsCount / totalPossibleSlots) * 100) : 0;

            if (availableSlotsElement) availableSlotsElement.textContent = availableSlots;
            if (utilizationRateElement) utilizationRateElement.textContent = `${utilizationRate}%`;
        }

        function refreshSchedule() {
            loadScheduleForDate();
        }

        // Appointment management functions
        function viewAppointment(appointmentId) {
            const appointment = scheduleData.appointments.find(apt => apt.id === appointmentId);
            if (appointment) {
                const staff = scheduleData.staff.find(s => s.id === appointment.staffId);
                showNotification(`
                    <strong>${appointment.clientName}</strong><br>
                    Service: ${appointment.service}<br>
                    Staff: ${staff ? staff.name : 'Unknown'}<br>
                    Time: ${appointment.startTime} - ${appointment.endTime}<br>
                    Duration: ${appointment.duration} minutes
                `, 'info', 5000);
            }
        }

        function editAppointment(appointmentId) {
            showNotification('Edit functionality coming soon!', 'info');
        }

        function cancelAppointment(appointmentId) {
            if (confirm('Are you sure you want to cancel this appointment?')) {
                showNotification('Cancel functionality coming soon!', 'warning');
            }
        }

        // Enhanced notification system
        function showNotification(message, type = 'success', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `alert alert-${type === 'success' ? 'success' : type === 'error' ? 'danger' : type === 'warning' ? 'warning' : 'info'} position-fixed`;
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.zIndex = '9999';
            notification.style.minWidth = '300px';
            notification.style.animation = 'slideInRight 0.3s ease-out';

            notification.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : type === 'warning' ? 'exclamation-triangle' : 'info-circle'} me-2"></i>
                    <div>${message}</div>
                    <button type="button" class="btn-close ms-auto" onclick="this.parentElement.parentElement.remove()"></button>
                </div>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOutRight 0.3s ease-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, duration);
        }

        // Add animation keyframes
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Global mouse up handler to ensure dragging stops even if mouse button is released outside a slot
        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                // Clean up any lingering visual indicators
                document.querySelectorAll('.time-slot').forEach(slot => {
                    slot.style.backgroundColor = '';
                });
                if (dragSelection && dragSelection.parentNode) {
                    dragSelection.parentNode.removeChild(dragSelection);
                }
                dragStart = null;
                dragSelection = null;
            }
        });
    </script>
</body>
</html>