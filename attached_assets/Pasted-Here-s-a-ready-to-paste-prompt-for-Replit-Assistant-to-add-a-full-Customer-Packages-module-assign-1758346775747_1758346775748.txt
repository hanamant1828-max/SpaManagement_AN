Here’s a ready-to-paste prompt for Replit Assistant to add a full “Customer Packages” module: assign packages to customers, record usage, and track remaining balance—clean Flask + Jinja + Bootstrap + vanilla JS.

Prompt for Replit Assistant (paste everything below):

Add a new Customer Packages feature (assign → use → track remaining). Stack: Flask + SQLAlchemy (Postgres) + Jinja + Bootstrap + vanilla JS. No auth/CSRF in dev.

Files

Backend

modules/packages/routes.py (Blueprint packages_bp, url_prefix="/packages")

modules/packages/api.py (JSON endpoints)

models/package.py (SQLAlchemy models)

Alembic migration (or raw SQL) for new tables

Frontend

templates/packages/customer_packages.html

static/js/packages.js

static/css/packages.css

Nav: add Packages → url_for('packages.index')

Data model (SQLAlchemy)

Create these tables (adjust to existing naming conventions like client for customers):

service (assume it already exists; if not, create minimal: id, name)

package_template
id, name, description, pkg_type ENUM('session','value') DEFAULT 'session', price NUMERIC(10,2), is_active BOOL

package_template_item (components per service)
id, package_id FK, service_id FK, qty INTEGER (for value-type packages, omit items)

customer_package
id, customer_id FK -> client.id, package_id FK, assigned_on, expires_on NULLABLE, price_paid NUMERIC(10,2), discount NUMERIC(10,2) DEFAULT 0, status ENUM('active','completed','expired','paused') DEFAULT 'active', notes TEXT

customer_package_item (per-service balances)
id, customer_package_id FK, service_id FK, total_qty INTEGER, used_qty INTEGER DEFAULT 0, remaining_qty INTEGER GENERATED ALWAYS AS (GREATEST(total_qty - used_qty,0)) STORED

package_usage (audit log)
id, customer_package_id FK, customer_package_item_id FK NULL, usage_date TIMESTAMP, service_id FK NULL, qty INTEGER DEFAULT 0, change_type ENUM('use','refund','adjust') DEFAULT 'use', staff_id FK NULL, appointment_id FK NULL, notes TEXT

Indexes: (customer_id, status), (customer_package_id), (service_id).

API (JSON)

All return {success: bool, ...}. Use @packages_bp.route.

GET /api/templates → list package templates with items

POST /api/assign → body: { customer_id, package_id, price_paid, discount, expires_on, notes }
Creates customer_package + its customer_package_item rows from template items.

GET /api/customer-packages → filters: customer_id? status? q? page?
Returns table data with computed totals (total, used, remaining, percent).

GET /api/customer-packages/<int:id> → details (header + items + recent usage)

GET /api/customer-packages/<int:id>/usage → paged usage list

POST /api/customer-packages/<int:id>/use
Body: { service_id, qty, usage_date, staff_id?, appointment_id?, notes? }
Validations: package active; item exists; qty > 0; qty <= remaining.

POST /api/customer-packages/<int:id>/adjust
Body: { service_id, qty, reason, change_type: 'refund' | 'adjust' }
For refund: add back qty; for adjust: add/subtract based on sign of qty. Never allow negative remaining.

Auto-status: when all item remaining_qty == 0 → set status completed. If expires_on < today → expired.

Server messages (map to toasts):

404: “Package not found.”

409: “Not enough balance for this service.”

400: “Please provide a valid quantity.”

Page UI (/packages)

Jinja template with Bootstrap cards + tables. Include:

Header bar: Search by customer/package, filters (Status: Active/Completed/Expired/Paused), date range, button Assign Package.

Table: columns → Customer, Package, Assigned/Expires, Total, Used, Remaining, Progress bar, Status, Actions (View ▸, Use, Adjust, More…).

Assign Package modal (non-dismissable except Save/Close):

Fields: Customer (select2-style search), Package Template (select), Price Paid, Discount, Expires On (optional), Notes.

Preview component breakdown (service + qty).

Save → calls /api/assign.

Package Details modal:

Header summary (customer, package, price, status, assigned/expires).

Per-service chips with total / used / remaining and mini bars.

Recent Usage list (date, service, qty, staff, notes).

Buttons: Record Usage, Adjust/Refund, Close.

Record Usage modal:

Service (dropdown limited to package items), Quantity (min 1, max remaining), Date/Time (default now), Staff (optional), Notes.

Live hint: “Remaining after this: X”.

Adjust/Refund modal:

Mode toggle: Refund | Adjust

Service, Quantity (positive integer), Reason (required).

Live hint reflects new remaining.

Validation & UX

Inline validation with Bootstrap invalid-feedback.

Disable primary buttons until valid.

On success: single success toast; table & details refresh.

On error: keep modal open; inline messages + toast (friendly copy).

Frontend JS (static/js/packages.js)

Initialize filters; fetch table (GET /api/customer-packages).

openAssignModal() → load templates & customers; save.

openDetails(id) → fetch details + usage.

openUseModal(id, service_id?) → prefill; post to /use.

openAdjustModal(id, service_id?) → post to /adjust.

Helpers to format qty, percent, and progress bars.

Non-dismissable modals: close only on Close/Save buttons.

Nav & route

Blueprint:

packages_bp = Blueprint("packages", __name__, url_prefix="/packages")
@packages_bp.route("/", endpoint="index")
def index():
    return render_template("packages/customer_packages.html")


Register: app.register_blueprint(packages_bp)

Acceptance Criteria

I can assign a package to a customer; items are created from template.

On the list, I see Total / Used / Remaining with a progress bar and status.

I can record usage; remaining decreases; cannot exceed balance; usage log shows entry.

I can refund/adjust; remaining updates and never goes negative.

When remaining hits 0, status becomes Completed; expired dates show Expired.

Filters/search work; all API responses are 2xx/404/409 with friendly messages.

Modals close only on Close/Save; no console errors.

If any file paths or models differ (e.g., Client vs Customer), adapt names but keep all functionality and UX exactly as specified