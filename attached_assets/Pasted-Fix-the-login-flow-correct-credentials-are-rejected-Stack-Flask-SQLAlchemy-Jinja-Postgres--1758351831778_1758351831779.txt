Fix the login flow: correct credentials are rejected. Stack: Flask + SQLAlchemy + Jinja (Postgres). Make username/email login work and add a safe admin reset for dev.

1) Diagnose quickly

Open the login handler (e.g., @app.post('/api/auth/login')).

Log (to console) the identifier normalization and which user row is found (without printing the password hash).

Confirm the request payload keys (UI sends identifier, password). If UI sends username/email instead, normalize.

2) Normalize + lookup by username OR email (case-insensitive)
identifier = request.json.get("identifier","").strip()
password   = request.json.get("password","")
ident_l    = identifier.lower()

from sqlalchemy import or_, func
user = (db.session.query(User)
        .filter(or_(func.lower(User.username)==ident_l,
                    func.lower(User.email)==ident_l))
        .first())
if not user:
    return jsonify(success=False, message="Invalid credentials"), 401

3) Password verification with fallback (hash drift)

Support current and legacy hashes. Prefer werkzeug (pbkdf2) or bcrypt; try both:

from werkzeug.security import check_password_hash
import bcrypt

def verify_pwd(stored, given):
    # bcrypt
    if stored.startswith("$2a$") or stored.startswith("$2b$") or stored.startswith("$2y$"):
        return bcrypt.checkpw(given.encode(), stored.encode())
    # werkzeug pbkdf2
    try:
        return check_password_hash(stored, given)
    except Exception:
        return False

if not verify_pwd(user.password_hash, password):
    return jsonify(success=False, message="Invalid credentials"), 401

4) Session cookie works in Replit

Ensure dev settings:

app.config.update(
    SECRET_KEY=os.getenv("SECRET_KEY","dev-secret"),
    SESSION_COOKIE_SAMESITE="Lax",
    SESSION_COOKIE_SECURE=False,   # dev
)


On success set session and return 200:

session.clear()
session["uid"] = user.id
return jsonify(success=True), 200


Disable CSRF only for this login API in dev.

5) User status checks (don’t silently fail)

If user.is_active exists and is False → return 403 with message “Your account is inactive.”

6) Add a dev-only admin reset route (guarded)

Create /dev/reset-admin that (in DEV only) creates or fixes the admin user:

@app.post("/dev/reset-admin")
def dev_reset_admin():
    if os.getenv("FLASK_ENV") != "development":
        return "forbidden", 403
    username = "admin"
    email    = "admin@example.com"
    plain    = "admin123"

    u = User.query.filter(func.lower(User.username)=="admin").first()
    if not u:
        u = User(username=username, email=email, is_active=True, role="admin")
        db.session.add(u)
    # set pbkdf2 hash
    from werkzeug.security import generate_password_hash
    u.password_hash = generate_password_hash(plain)  # pbkdf2:sha256
    db.session.commit()
    return jsonify(success=True, message="Admin reset to admin/admin123")

7) Frontend form

Send JSON {identifier, password} with credentials: 'include'.

Trim inputs; disable Sign In button while awaiting response.

Map responses:

200 → redirect dashboard

401 → show “Incorrect username/email or password.”

403 → show “Your account is inactive.”

others → “Unable to sign in. Please try again.”

8) QA checklist (must pass)

Call POST /dev/reset-admin (dev only) → returns success.

Login with admin / admin123 → 200; cookie set; dashboard loads.

Login with admin@example.com
 / admin123 → also works.

Wrong password → 401 with inline message.

Inactive user (toggle) → 403.

Hard refresh still authenticated (session persists).

No console/server errors.