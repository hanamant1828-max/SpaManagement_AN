TASK: Reuse "Book Multiple Appointments" modal for EDITING appointments (remove separate edit modal)

CURRENT SITUATION:
- Separate modals: #multiBookModal (for creating) and #editAppointmentModal (for editing)
- Code duplication between create and edit functionality
- Want to use ONE modal for both create and edit operations

REQUIRED CHANGES:

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. REMOVE SEPARATE EDIT MODAL:
   - Delete entire #editAppointmentModal HTML block
   - Keep only #multiBookModal

2. ADD MODE TRACKING TO MULTI-BOOKING MODAL:

Add hidden input to track mode and appointment ID:

<div class="modal fade" id="multiBookModal">
    <input type="hidden" id="modalMode" value="create">
    <input type="hidden" id="editingAppointmentId" value="">
    <!-- rest of modal content -->
</div>

3. UPDATE MODAL TITLE & BUTTON DYNAMICALLY:

Change modal header to use dynamic IDs:

<div class="modal-header">
    <h5 class="modal-title" id="multiBookModalTitle">
        <div class="modal-icon">
            <i class="fas fa-calendar-check" id="multiBookModalIcon"></i>
        </div>
        <span id="multiBookModalTitleText">Book Multiple Appointments</span>
    </h5>
    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
</div>

Change footer button:

<button 
    type="button" 
    class="btn btn-primary" 
    onclick="submitMultiAppointment()"
    id="submitMultiBookBtn"
>
    <i class="fas fa-check-circle me-2"></i>
    <span id="submitBtnText">Book All Appointments</span>
</button>

4. UPDATE openMultiBookModal() TO SUPPORT MODES:

function openMultiBookModal(mode = 'create', appointmentData = null) {
    const modal = new bootstrap.Modal(document.getElementById("multiBookModal"));
    
    // Set mode
    document.getElementById('modalMode').value = mode;
    
    if (mode === 'edit' && appointmentData) {
        // EDIT MODE
        document.getElementById('editingAppointmentId').value = appointmentData.id;
        
        // Update UI for edit mode
        document.getElementById('multiBookModalTitleText').textContent = 'Edit Appointment';
        document.getElementById('multiBookModalIcon').className = 'fas fa-edit';
        document.getElementById('submitBtnText').textContent = 'Update Appointment';
        document.getElementById('appointmentCount').textContent = '1 Appointment';
        
        // Hide "Add Another Appointment" button in edit mode
        document.querySelector('.add-appointment-btn').style.display = 'none';
        
        // Pre-fill the form with existing data
        prefillEditData(appointmentData);
        
    } else {
        // CREATE MODE
        document.getElementById('editingAppointmentId').value = '';
        
        // Update UI for create mode
        document.getElementById('multiBookModalTitleText').textContent = 'Book Multiple Appointments';
        document.getElementById('multiBookModalIcon').className = 'fas fa-calendar-check';
        document.getElementById('submitBtnText').textContent = 'Book All Appointments';
        
        // Show "Add Another Appointment" button
        document.querySelector('.add-appointment-btn').style.display = 'flex';
        
        // Reset form
        resetMultiBookModal();
    }
    
    modal.show();
}

5. CREATE PREFILL FUNCTION:

function prefillEditData(appointmentData) {
    console.log('ğŸ“ Pre-filling edit data:', appointmentData);
    
    // Reset to single appointment
    const container = document.getElementById("appointmentsContainer");
    container.querySelectorAll(".appointment-card:not(:first-child)").forEach(card => card.remove());
    
    const firstCard = container.querySelector(".appointment-card");
    if (!firstCard) return;
    
    // Hide remove button for single appointment
    firstCard.querySelector('.remove-appointment').classList.add('d-none');
    
    // Pre-fill client - must match the appointment's client
    const clientSelect = document.getElementById('multiClientSelect');
    if (clientSelect && appointmentData.client_id) {
        clientSelect.value = appointmentData.client_id;
        
        // Trigger Select2 update
        if (typeof $.fn.select2 !== 'undefined') {
            $(clientSelect).trigger('change');
        } else {
            clientSelect.dispatchEvent(new Event('change'));
        }
    }
    
    // Make client select readonly in edit mode
    clientSelect.disabled = true;
    
    // Pre-fill service
    const serviceSelect = firstCard.querySelector('.service-select');
    if (serviceSelect && appointmentData.service_id) {
        serviceSelect.value = appointmentData.service_id;
        
        // Trigger Select2 update
        if (typeof $.fn.select2 !== 'undefined') {
            $(serviceSelect).trigger('change');
        }
    }
    
    // Pre-fill staff
    const staffSelect = firstCard.querySelector('.staff-select');
    if (staffSelect && appointmentData.staff_id) {
        staffSelect.value = appointmentData.staff_id;
        
        // Trigger Select2 update
        if (typeof $.fn.select2 !== 'undefined') {
            $(staffSelect).trigger('change');
        }
    }
    
    // Pre-fill date
    const dateInput = firstCard.querySelector('.appointment-date');
    if (dateInput && appointmentData.appointment_date) {
        dateInput.value = appointmentData.appointment_date;
    }
    
    // Pre-fill start time
    const startTimeInput = firstCard.querySelector('.start-time');
    if (startTimeInput && appointmentData.start_time) {
        startTimeInput.value = appointmentData.start_time;
    }
    
    // Pre-fill end time
    const endTimeInput = firstCard.querySelector('.end-time');
    if (endTimeInput && appointmentData.end_time) {
        endTimeInput.value = appointmentData.end_time;
    }
    
    // Pre-fill notes
    const notesInput = document.getElementById('multiNotes');
    if (notesInput && appointmentData.notes) {
        notesInput.value = appointmentData.notes;
    }
    
    // Update summary
    calculateEndTime(0);
    updateSummary();
    updateSubmitButton();
    
    console.log('âœ… Edit data pre-filled successfully');
}

6. UPDATE submitMultiAppointment() TO HANDLE BOTH MODES:

async function submitMultiAppointment() {
    const mode = document.getElementById('modalMode').value;
    
    if (mode === 'edit') {
        // EDIT MODE - Update single appointment
        await updateAppointment();
    } else {
        // CREATE MODE - Book multiple appointments
        await bookMultipleAppointments();
    }
}

7. CREATE SEPARATE UPDATE FUNCTION:

async function updateAppointment() {
    console.log('ğŸ”„ Updating appointment...');
    
    const appointmentId = document.getElementById('editingAppointmentId').value;
    if (!appointmentId) {
        alert('âŒ Error: No appointment ID found');
        return;
    }
    
    const clientSelect = document.getElementById('multiClientSelect');
    if (!clientSelect.value) {
        alert('âŒ Please select a client');
        return;
    }
    
    const firstCard = document.querySelector('.appointment-card');
    const serviceSelect = firstCard.querySelector('.service-select');
    const staffSelect = firstCard.querySelector('.staff-select');
    const dateInput = firstCard.querySelector('.appointment-date');
    const startTimeInput = firstCard.querySelector('.start-time');
    const endTimeInput = firstCard.querySelector('.end-time');
    const notesInput = document.getElementById('multiNotes');
    
    // Validation
    if (!serviceSelect.value || !staffSelect.value || !dateInput.value || 
        !startTimeInput.value || !endTimeInput.value) {
        alert('âŒ Please fill in all required fields');
        return;
    }
    
    // Prepare update data
    const updateData = {
        service_id: parseInt(serviceSelect.value),
        service_name: serviceSelect.options[serviceSelect.selectedIndex].text.split(' (')[0],
        staff_id: parseInt(staffSelect.value),
        appointment_date: dateInput.value,
        start_time: startTimeInput.value,
        end_time: endTimeInput.value,
        notes: notesInput.value || ''
    };
    
    console.log('ğŸ“¤ Sending update:', updateData);
    
    // Disable button
    const submitBtn = document.getElementById('submitMultiBookBtn');
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Updating...';
    
    try {
        const response = await fetch(`/api/unaki/bookings/${appointmentId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(updateData)
        });
        
        const result = await response.json();
        console.log('ğŸ“¥ Update response:', result);
        
        if (result.success) {
            alert('âœ… Appointment updated successfully!');
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById('multiBookModal')).hide();
            
            // Reload bookings
            loadBookings();
            
        } else {
            throw new Error(result.error || 'Failed to update appointment');
        }
        
    } catch (error) {
        console.error('âŒ Error:', error);
        alert('âŒ Error updating appointment: ' + error.message);
    } finally {
        // Re-enable button
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fas fa-check-circle me-2"></i><span id="submitBtnText">Update Appointment</span>';
    }
}

8. RENAME OLD SUBMIT FUNCTION:

Rename current submitMultiAppointment() to bookMultipleAppointments():

async function bookMultipleAppointments() {
    // Keep all existing booking logic here
    console.log('ğŸ“ Booking multiple appointments...');
    
    // ... existing booking code ...
}

9. UPDATE EDIT BUTTON CLICK HANDLER:

Replace the current editAppointment() function:

function editAppointment() {
    if (!selectedAppointmentId) {
        console.error('No appointment selected');
        return;
    }
    
    console.log('âœï¸ Edit appointment:', selectedAppointmentId);
    
    // Find appointment data
    const appointmentData = bookingsData.find(b => b.id == selectedAppointmentId);
    
    if (!appointmentData) {
        alert('âŒ Appointment not found');
        return;
    }
    
    // Close context menu
    hideContextMenu();
    
    // Open modal in edit mode with pre-filled data
    openMultiBookModal('edit', appointmentData);
}

10. UPDATE MODAL CLOSE HANDLER:

Re-enable client select when closing modal:

document.getElementById('multiBookModal').addEventListener('hidden.bs.modal', function() {
    // Re-enable client select
    const clientSelect = document.getElementById('multiClientSelect');
    if (clientSelect) {
        clientSelect.disabled = false;
    }
    
    // Show add appointment button
    const addBtn = document.querySelector('.add-appointment-btn');
    if (addBtn) {
        addBtn.style.display = 'flex';
    }
    
    // Reset mode
    document.getElementById('modalMode').value = 'create';
    document.getElementById('editingAppointmentId').value = '';
});

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TESTING CHECKLIST:
âœ“ Click "New Appointment" - modal opens in CREATE mode
âœ“ Can add multiple appointments
âœ“ Can book multiple appointments successfully
âœ“ Right-click appointment â†’ Edit - modal opens in EDIT mode
âœ“ Form is pre-filled with existing data
âœ“ Client dropdown is disabled (read-only)
âœ“ "Add Another Appointment" button is hidden
âœ“ Title shows "Edit Appointment"
âœ“ Button shows "Update Appointment"
âœ“ Can update appointment successfully
âœ“ Modal closes after update
âœ“ Calendar refreshes with updated data

BENEFITS:
âœ… Single modal for both create and edit
âœ… No code duplication
âœ… Consistent UI/UX
âœ… Easier maintenance
âœ… Less HTML/CSS to manage