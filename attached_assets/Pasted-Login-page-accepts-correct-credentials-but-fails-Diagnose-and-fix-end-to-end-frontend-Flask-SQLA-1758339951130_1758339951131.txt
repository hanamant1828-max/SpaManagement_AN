Login page accepts correct credentials but fails. Diagnose and fix end-to-end (frontend + Flask/SQLAlchemy backend with Postgres).

1) Reproduce & capture

Open DevTools → Network while submitting login.

Note request URL, payload keys, status, and any Set-Cookie headers.

If there’s a redirect loop to /login, capture it.

2) Frontend form fixes

Ensure the form sends what the API expects:

One identifier field called identifier (user can enter username or email) and password.

Trim and lowercase identifier; trim password.

Submit as JSON to /api/auth/login with credentials: 'include'.

Show inline errors from API; don’t swallow them.

Confirm the submit button is not disabled and no JS error blocks submission.

3) Backend handler (Flask) fixes

Implement robust login that works for username or email:

# POST /api/auth/login
# payload: {"identifier": "...", "password": "..."}

identifier = request.json.get("identifier","").strip().lower()
password   = request.json.get("password","")

# Lookup by email (case-insensitive) OR username (case-insensitive)
user = (db.session.query(User)
        .filter(or_(func.lower(User.email)==identifier,
                    func.lower(User.username)==identifier))
        .first())

# If not found or password wrong -> 401
# Use werkzeug.security.check_password_hash (or passlib context) to verify.
# If you previously changed hashing scheme, add fallback verify (e.g., try bcrypt then pbkdf2).
# Also check user.is_active (if field exists) and return 403 if false.

# On success: create session cookie
session['uid'] = user.id
resp = jsonify({"success": True})
resp.set_cookie(
    key="session",
    value=session.sid if hasattr(session, 'sid') else request.cookies.get('session'),
    httponly=True, samesite="Lax", secure=False  # dev settings
)
return resp, 200

4) Common root-causes to fix (apply all that match)

Hash mismatch: ensure the same hashing algo used for registration is used here (check_password_hash vs stored hash). If older users have a different scheme, support fallback.

Wrong field names: backend expecting username/email while UI sends identifier. Align both sides.

Case sensitivity: compare lower() for username/email.

Trailing spaces in inputs: always strip.

CSRF on login: disable CSRF for this auth route in dev or include a valid token; otherwise 403/redirect.

Cookie/session config in dev:

SECRET_KEY set,

SESSION_COOKIE_SAMESITE='Lax',

SESSION_COOKIE_SECURE=False,

don’t set SESSION_COOKIE_DOMAIN in Replit,

if using app.proxyfix/trust proxy, configure correctly so cookies aren’t dropped.

If using JWT:

Same JWT_SECRET_KEY everywhere, HS256, not expired, clock skew handled.

Send Authorization: Bearer … and set withCredentials off (cookies not used).

5) Frontend after login

On 200: route to dashboard; keep the session cookie (verify in Application → Cookies).

On 401/403: show friendly message:

401: “Incorrect username/email or password.”

403: “Your account is inactive. Please contact admin.”

6) QA (must pass)

Login with username + password → success.

Login with email + password → success.

Wrong password → 401 with inline message.

Inactive user → 403 with message.

Refresh after login → stays logged in (cookie present).

No console errors; all network responses as expected.