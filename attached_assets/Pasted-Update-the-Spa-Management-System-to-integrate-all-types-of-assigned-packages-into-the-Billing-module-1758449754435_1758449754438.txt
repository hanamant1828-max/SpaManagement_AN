Update the Spa Management System to integrate all types of assigned packages into the Billing module.

Goals:
- Apply package benefits automatically during billing (free/discount/prepaid/unlimited).
- Track usage/balances accurately and safely (including concurrency, refunds, and voids).
- Show clear breakdowns on the invoice and in customer history.

Requirements:

1) Package Tracking
- When a package is assigned to a customer, store all included services, discounts, or prepaid credits in a tracking table.
- For each service inside a package, track:
  • total_allocated (number of uses, prepaid balance amount, or unlimited)
  • used_count
  • remaining_count (omit/NULL if unlimited)
  • benefit_type (free | discount | prepaid | unlimited)
- For prepaid, track monetary balance:
  • balance_total, balance_used, balance_remaining
- Persist per-customer-per-package usage history entries on each billing event.
- Ensure timestamps use server timezone consistently.

2) Billing Logic
- On billing each line item:
  • Find customer’s ACTIVE packages: valid_from ≤ today ≤ valid_to AND status=active.
  • Identify packages covering the service (by service_id mapping or “all services” rule for memberships).
  • Apply benefit by priority (see Section 3):
      - FREE with limit → deduct 1 usage, final_price = 0.
      - DISCOUNT → apply % discount, final_price = price - (price * %).
      - PREPAID → deduct from monetary balance until exhausted; if partial remains, charge the difference.
      - UNLIMITED → final_price = 0 (only validity check).
  • If no package covers the service → charge full price.
- Record exactly which package was applied on each line item.

3) Multiple Packages & Priority Rules
- If multiple packages can apply to the same service, use this default priority (lowest number wins):
  1. Unlimited (membership) covering the service
  2. Free allocations with remaining_count > 0
  3. Discount percentage (highest % wins if multiple)
  4. Prepaid balance
- Provide a staff override option to pick a different eligible package.
- Persist which rule was chosen (auto or manual) for audit.

4) Validation & Guardrails
- Apply package ONLY IF:
  • Package is active: valid_from ≤ charge_date ≤ valid_to
  • Service is covered by package rules
  • For limited-use: remaining_count > 0
  • For prepaid: balance_remaining > 0
- Prevent duplicate deductions for the same invoice/line via idempotency key:
  • idempotency_key = concat(invoice_id, line_id)
  • All package writes must be conditional on unused idempotency_key
- Concurrency:
  • Wrap apply/deduct in a transaction with row-level locking (select-for-update or equivalent).
  • Re-check remaining_count / balance_remaining inside the transaction before commit.

5) Refunds / Voids / Edits
- If an invoice/line is voided or refunded:
  • Reverse the usage history entry
  • Restore remaining_count or prepaid balance
  • Log a reversal record referencing the original usage entry (bi-directional link)
- If an invoice line is edited (service change or price change), recompute benefits with a new idempotency_key and reverse the prior usage.

6) Invoice / UI Integration
- On each invoice line show:
  • Service Name
  • Normal Price
  • Package Applied (package name)
  • Benefit Type (Free | Discount % | Prepaid Deduction | Unlimited)
  • Remaining (uses or prepaid balance) AFTER application (if applicable)
  • Final Price
- Examples:
  • Haircut | ₹500 | Covered by Luxe Club (Unlimited) | ₹0
  • Pedicure | ₹800 | Student Offer 30% off | ₹560
  • Facial | ₹1,200 | Prepaid Deduction ₹1,200 | ₹0 (Balance left: ₹3,800)

7) Reporting & Customer Profile
- Maintain usage history with fields:
  • customer_id, package_id, service_id (nullable for prepaid-only), invoice_id, line_id, idempotency_key
  • benefit_type, qty_deducted (or amount for prepaid), balance_after, created_at
- Customer Profile → Assigned Packages tab:
  • Show active/expired status, validity dates
  • For each service benefit: total, used, remaining (or “Unlimited”)
  • For prepaid: total, used, remaining with last-activity date

8) Admin & Ops
- Feature flag the new billing integration to allow safe rollout.
- Add a dry-run mode on invoice preview to show “what would be applied” without committing deductions.
- Log all apply/reverse operations with who/when for audit.

9) Edge Cases
- Multiple active packages covering same service → follow priority or staff override.
- Package expiring today → still valid through end-of-day.
- Partial prepaid coverage → apply remaining prepaid, charge rest in cash/card.
- Backdated invoices → apply package validity against the charge date (not current date).
- Taxes/discount order: apply package benefit BEFORE tax unless local rules require otherwise (make configurable).
- Complimentary (₹0) services should still create a usage entry.

10) Acceptance Criteria (QA)
- Limited-use: After 2 billings on a 4-use benefit, remaining shows 2; 3rd/4th consume correctly; 5th bills full.
- Discount: 30% package discount applies; higher competing discount (40%) chosen automatically.
- Prepaid: Deducts correctly, handles partial coverage, cannot go negative, reverses on refund.
- Unlimited: Always ₹0 while valid; invoice shows membership coverage.
- Idempotency: Re-posting same invoice/line does not double-deduct.
- Concurrency: Two simultaneous billings of same benefit do not overspend usage/balance.
- Reversal: Refund restores counts/balance and creates a linked reversal record.

Deliverables:
- DB migrations for any new fields/tables (usage history, idempotency keys, audit logs).
- Service-layer functions for: evaluate benefits, apply benefit, reverse benefit.
- Updates to invoice calculation pipeline and invoice UI.
- Unit tests + end-to-end tests covering acceptance criteria above.
