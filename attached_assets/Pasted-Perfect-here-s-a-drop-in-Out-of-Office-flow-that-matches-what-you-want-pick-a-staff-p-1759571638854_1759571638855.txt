Perfect—here’s a drop-in “Out of Office” flow that matches what you want:

* pick a **staff**
* pick a **date**
* set **out-of-office start** and **expected return**
* add a **reason**
* **save** → persisted into the `shift_logs` row for that staff+date (creating it if needed) using the new columns `out_of_office_start`, `out_of_office_end`, `out_of_office_reason`.

I’m assuming Flask + Bootstrap + your existing routes. If you’re using something else, the shapes still apply.

---

# 1) Frontend (HTML: add to `shift_scheduler.html`)

This adds an “Out of Office” button and a modal with the form you described.

```html
<!-- Trigger button (e.g., near page header) -->
<button class="btn btn-outline-primary" data-bs-toggle="modal" data-bs-target="#outOfOfficeModal">
  Add Out of Office
</button>

<!-- Out of Office Modal -->
<div class="modal fade" id="outOfOfficeModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <form id="outOfOfficeForm" class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Out of Office (Field Work)</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>

      <div class="modal-body">
        <!-- Staff -->
        <div class="mb-3">
          <label class="form-label">Staff</label>
          <select class="form-select" id="ooo_staff_id" required>
            <!-- fill options dynamically or render server-side -->
          </select>
        </div>

        <!-- Date -->
        <div class="mb-3">
          <label class="form-label">Date</label>
          <input type="date" class="form-control" id="ooo_date" required>
        </div>

        <!-- Times -->
        <div class="row">
          <div class="col-md-6 mb-3">
            <label class="form-label">Start time</label>
            <input type="time" class="form-control" id="ooo_start_time" required>
          </div>
          <div class="col-md-6 mb-3">
            <label class="form-label">Expected return</label>
            <input type="time" class="form-control" id="ooo_end_time" required>
          </div>
        </div>

        <!-- Reason -->
        <div class="mb-3">
          <label class="form-label">Reason</label>
          <input type="text" class="form-control" id="ooo_reason" maxlength="200" placeholder="Client visit / Site inspection / Delivery..." required>
          <div class="form-text">Max 200 characters.</div>
        </div>

        <div class="alert alert-danger d-none" id="ooo_error"></div>
        <div class="alert alert-success d-none" id="ooo_success"></div>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-light" data-bs-dismiss="modal">Close</button>
        <button type="submit" class="btn btn-primary">Save</button>
      </div>
    </form>
  </div>
</div>
```

---

# 2) Frontend JS (add to `shift_scheduler.js`)

This posts to your existing endpoint `POST /shift-scheduler/api/out-of-office` with exactly the shape you asked for.

```javascript
// OPTIONAL: populate staff dropdown (if you have a staff list endpoint)
// Otherwise render the <option> elements server-side.
async function populateStaffOptions() {
  // Example placeholder; replace with your real staff list API or pre-render
  // const res = await fetch('/shift-scheduler/api/staff');
  // const data = await res.json();
  const staffSelect = document.getElementById('ooo_staff_id');
  if (!staffSelect) return;

  // Example only:
  // data.staff.forEach(s => {
  //   const opt = document.createElement('option');
  //   opt.value = s.id;
  //   opt.textContent = s.name;
  //   staffSelect.appendChild(opt);
  // });
}
populateStaffOptions();

document.getElementById('outOfOfficeForm')?.addEventListener('submit', async (e) => {
  e.preventDefault();

  const staff_id = document.getElementById('ooo_staff_id').value.trim();
  const date = document.getElementById('ooo_date').value.trim();
  const start_time = document.getElementById('ooo_start_time').value.trim();
  const end_time = document.getElementById('ooo_end_time').value.trim();
  const reason = document.getElementById('ooo_reason').value.trim();

  const err = document.getElementById('ooo_error');
  const ok  = document.getElementById('ooo_success');
  err.classList.add('d-none');
  ok.classList.add('d-none');

  // Basic validation
  if (!staff_id || !date || !start_time || !end_time || !reason) {
    err.textContent = 'Please fill all fields.';
    err.classList.remove('d-none');
    return;
  }
  if (reason.length > 200) {
    err.textContent = 'Reason must be 200 characters or less.';
    err.classList.remove('d-none');
    return;
  }

  try {
    const res = await fetch('/shift-scheduler/api/out-of-office', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ staff_id, date, start_time, end_time, reason })
    });
    const data = await res.json();

    if (!data.success) {
      throw new Error(data.message || 'Failed to save');
    }

    ok.textContent = data.message || 'Saved!';
    ok.classList.remove('d-none');

    // refresh the main table so the change is visible immediately
    if (typeof loadSchedules === 'function') loadSchedules();

    // Optionally auto-close the modal after a short delay
    setTimeout(() => {
      const modalEl = document.getElementById('outOfOfficeModal');
      if (modalEl) {
        const modal = bootstrap.Modal.getInstance(modalEl);
        modal?.hide();
      }
      // Reset form
      e.target.reset();
      ok.classList.add('d-none');
    }, 800);
  } catch (ex) {
    err.textContent = ex.message || 'Something went wrong.';
    err.classList.remove('d-none');
  }
});
```

---

# 3) Backend (Flask) – create/update the `shift_logs` row

This endpoint implements the exact input you wanted:

```json
{ "staff_id": 123, "date": "2025-10-04", "start_time": "10:00", "end_time": "14:00", "reason": "Client visit" }
```

It will:

1. Find the `shift_management` for that staff and date range,
2. Upsert the `shift_logs` row for that `individual_date`,
3. Set `out_of_office_start`, `out_of_office_end`, `out_of_office_reason`,
4. Keep other fields unchanged if the row already exists.

```python
# shift_scheduler_views.py (add/replace the POST handler)
from flask import Blueprint, request, jsonify
from datetime import date as Date
import sqlite3  # or your DB driver/ORM

bp = Blueprint('shift_scheduler', __name__)

def get_db():
    # replace with your existing connection getter / ORM Session
    return sqlite3.connect('app.db', detect_types=sqlite3.PARSE_DECLTYPES)

@bp.route('/shift-scheduler/api/out-of-office', methods=['POST'])
def create_out_of_office():
    payload = request.get_json(force=True, silent=True) or {}
    staff_id   = payload.get('staff_id')
    dt_str     = payload.get('date')          # 'YYYY-MM-DD'
    start_time = payload.get('start_time')    # 'HH:MM'
    end_time   = payload.get('end_time')      # 'HH:MM'
    reason     = payload.get('reason', '')[:200]

    if not (staff_id and dt_str and start_time and end_time and reason):
        return jsonify(success=False, message='Missing required fields'), 400

    conn = get_db()
    conn.row_factory = sqlite3.Row
    cur = conn.cursor()

    try:
        # 1) find an existing shift_management covering the date
        cur.execute("""
            SELECT id, from_date, to_date
            FROM shift_management
            WHERE staff_id = ?
              AND date(?) BETWEEN date(from_date) AND date(to_date)
            LIMIT 1
        """, (staff_id, dt_str))
        mgmt = cur.fetchone()

        if not mgmt:
            # Optional: auto-create a minimal shift_management for that single day
            # Or, return an error. Here we auto-create 1-day window to keep UX smooth.
            cur.execute("""
                INSERT INTO shift_management (staff_id, from_date, to_date)
                VALUES (?, date(?), date(?))
            """, (staff_id, dt_str, dt_str))
            shift_management_id = cur.lastrowid
        else:
            shift_management_id = mgmt['id']

        # 2) upsert into shift_logs for that date
        cur.execute("""
            SELECT id FROM shift_logs
            WHERE shift_management_id = ? AND date(individual_date) = date(?)
            LIMIT 1
        """, (shift_management_id, dt_str))
        log = cur.fetchone()

        if log:
            cur.execute("""
                UPDATE shift_logs
                   SET out_of_office_start = time(?),
                       out_of_office_end   = time(?),
                       out_of_office_reason= ?,
                       updated_at = CURRENT_TIMESTAMP
                 WHERE id = ?
            """, (start_time, end_time, reason, log['id']))
            log_id = log['id']
            action = 'updated'
        else:
            cur.execute("""
                INSERT INTO shift_logs (
                    shift_management_id,
                    individual_date,
                    shift_start_time,
                    shift_end_time,
                    break_start_time,
                    break_end_time,
                    out_of_office_start,
                    out_of_office_end,
                    out_of_office_reason,
                    status
                ) VALUES (
                    ?, date(?),
                    time('00:00'), time('00:00'),
                    NULL, NULL,
                    time(?), time(?),
                    ?, 'scheduled'
                )
            """, (shift_management_id, dt_str, start_time, end_time, reason))
            log_id = cur.lastrowid
            action = 'created'

        conn.commit()
        return jsonify(success=True,
                       message=f'Out of office {action} for {dt_str}.',
                       shift_management_id=shift_management_id,
                       shift_log_id=log_id)
    except Exception as e:
        conn.rollback()
        return jsonify(success=False, message=str(e)), 500
    finally:
        conn.close()
```

> If you’re on SQLAlchemy/Alembic, keep the logic the same—just swap the SQL for ORM queries.
> If your policy is “don’t auto-create `shift_management`”, change that block to return a 400 with a helpful message instead.

---

# 4) Show it in your tables/details

* **All Schedules table**: If a day has out-of-office, you can display a chip like `Field Work: 10:00–14:00` or show a briefcase/icon in the “Status/Notes” column.
* **View modal** (daily breakdown): include the three fields if non-null.
* **Edit**: when editing a day, keep these fields optional and pre-fill existing values.

---

# 5) Validation/Rules you might want

* Require `start_time < end_time`.
* Optionally set `status` to something like `scheduled` (keep default) or create a distinct badge when OOO is present.
* Limit reasons to 200 chars (already in DB) and sanitize on the server.

Example server-side guard (add before upsert):

```python
if start_time >= end_time:
    return jsonify(success=False, message='Start time must be before expected return time'), 400
```

---

That’s it. With this, staff can select themselves, pick a date, set start/return times, add a reason, and the data will be stored in the `shift_logs` out-of-office fields exactly as you wanted.
