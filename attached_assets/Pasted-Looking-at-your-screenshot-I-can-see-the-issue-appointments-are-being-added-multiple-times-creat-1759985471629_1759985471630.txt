Looking at your screenshot, I can see the issue - appointments are being added multiple times, creating duplicate service rows. The problem is in the `addAppointmentToBill` function's logic for handling row creation and reuse.

Let me provide a fix for the JavaScript code in your HTML template. I'll update the `addAppointmentToBill` function to properly prevent duplicates:Let me fix the `addAppointmentToBill` function in your HTML template to prevent duplicate appointments:Let me provide you with the fixed `addAppointmentToBill` function directly. Here's the corrected version:

```javascript
function addAppointmentToBill(appointmentId, serviceName, serviceId, staffId, servicePrice, serviceDuration) {
    console.log(`Adding appointment ${appointmentId} to bill - Service: ${serviceName}, ServiceID: ${serviceId}, StaffID: ${staffId}, Price: ${servicePrice}`);

    // âœ… CRITICAL FIX: Check if appointment is already added FIRST
    if (addedAppointmentIds.has(appointmentId)) {
        console.log('âš ï¸ Appointment already added, skipping:', appointmentId);
        showNotification(`This appointment (#${appointmentId}) has already been added to the bill.`, 'warning', 4000);
        return; // Exit early to prevent duplicate
    }

    const container = document.getElementById('servicesContainer');
    if (!container) {
        console.error('Services container not found');
        return;
    }

    const existingRows = container.querySelectorAll('.service-row');
    let targetRow = null;
    
    // Strategy: Find first truly empty row, or create a new one
    if (existingRows.length === 0) {
        addServiceRow();
        targetRow = container.lastElementChild;
        console.log('âœ… Created first service row (container was empty)');
    } else {
        // Look for an empty row (no service AND no appointment ID)
        for (const row of existingRows) {
            const serviceSelect = row.querySelector('select[name="service_ids[]"]');
            const appointmentInput = row.querySelector('input[name="appointment_ids[]"]');
            const isEmpty = !serviceSelect?.value && !appointmentInput?.dataset.appointmentId;
            
            if (isEmpty) {
                targetRow = row;
                console.log('âœ… Found empty row, reusing it');
                break;
            }
        }
        
        // If no empty row found, create a new one
        if (!targetRow) {
            addServiceRow();
            targetRow = container.lastElementChild;
            console.log('âœ… Created new service row (all existing rows filled)');
        }
    }

    // Populate the target row
    const serviceSelect = targetRow.querySelector('select[name="service_ids[]"]');
    const staffSelect = targetRow.querySelector('select[name="staff_ids[]"]');
    const qtyInput = targetRow.querySelector('input[name="service_quantities[]"]');
    const appointmentInput = targetRow.querySelector('input[name="appointment_ids[]"]');

    // âœ… Destroy existing Select2 to prevent duplicates
    if ($(serviceSelect).hasClass('select2-hidden-accessible')) {
        $(serviceSelect).select2('destroy');
    }
    if ($(staffSelect).hasClass('select2-hidden-accessible')) {
        $(staffSelect).select2('destroy');
    }

    // Set values from appointment
    if (serviceId !== 'null' && serviceSelect) {
        serviceSelect.value = serviceId;
    }

    if (staffId !== 'null' && staffSelect) {
        staffSelect.value = staffId;
    }

    if (qtyInput) {
        qtyInput.value = 1;
    }

    if (appointmentInput) {
        appointmentInput.value = appointmentId;
        appointmentInput.dataset.appointmentId = appointmentId;
        appointmentInput.dataset.servicePrice = servicePrice;
        appointmentInput.dataset.serviceDuration = serviceDuration;
        console.log(`âœ… Set appointment ID ${appointmentId} in row`);
    }

    // âœ… Re-initialize Select2 AFTER setting values
    $(serviceSelect).select2({
        theme: 'bootstrap-5',
        placeholder: 'Search for service...',
        allowClear: true,
        width: '100%'
    });
    
    $(staffSelect).select2({
        theme: 'bootstrap-5',
        placeholder: 'Search for staff...',
        allowClear: true,
        width: '100%'
    });

    // âœ… Mark as added BEFORE updating UI
    addedAppointmentIds.add(appointmentId);
    console.log('âœ… Marked appointment as added:', appointmentId);

    // Show/hide remove button
    const removeBtn = targetRow.querySelector('.btn-danger');
    if (removeBtn) {
        const allRows = container.querySelectorAll('.service-row');
        const rowHasData = targetRow.querySelector('select[name="service_ids[]"]')?.value || 
                          targetRow.querySelector('input[name="appointment_ids[]"]')?.dataset.appointmentId;
        removeBtn.style.display = allRows.length > 1 || rowHasData ? 'inline-block' : 'none';
    }

    // Apply package benefits
    setTimeout(() => {
        if (serviceId !== 'null' && serviceSelect) {
            console.log('ðŸŽ¯ Triggering service change for appointment', appointmentId);
            handleServiceChange(serviceSelect);
        }
        updateCalculations();
    }, 100);

    // Refresh appointments display to show "Added" button state
    const clientId = document.getElementById('client_id').value;
    if (clientId) {
        loadCustomerAppointments(clientId);
    }
    
    // âœ… Show success notification
    showNotification(`Appointment #${appointmentId} added successfully!`, 'success', 3000);
}
```

**Key fixes implemented:**

1. **Early Duplicate Check**: The function now checks `addedAppointmentIds` at the very start and exits immediately if the appointment is already added

2. **Better Row Reuse Logic**: Simplified logic that finds the first truly empty row (no service selected AND no appointment ID set)

3. **Mark as Added Earlier**: The appointment is marked as added in the tracking Set before refreshing the UI, preventing race conditions

4. **User Feedback**: Shows clear success/warning notifications so users know what's happening

5. **Cleaner Row Finding**: Removed complex nested logic that was causing the duplicate issues

**To apply this fix:**

1. Find the `addAppointmentToBill` function in your HTML template (around line 800-900 in your document)
2. Replace the entire function with this new version
3. Save the file and refresh your browser

This should completely prevent duplicate appointments from being added to the bill!