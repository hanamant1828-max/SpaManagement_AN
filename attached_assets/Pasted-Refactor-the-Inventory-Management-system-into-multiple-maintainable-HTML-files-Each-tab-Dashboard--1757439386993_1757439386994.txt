Refactor the Inventory Management system into multiple maintainable HTML files. Each tab (Dashboard, Product Master, Categories, Add Inventory Items, Consumption) will have its own standalone HTML file that includes the HTML layout and its JavaScript logic together. The UI must remain exactly the same.‚Äù

1) File structure

Create a new folder /inventory/ with these files:

/inventory/dashboard.html

/inventory/product-master.html

/inventory/categories.html

/inventory/adjustments.html (for Add Inventory Items)

/inventory/consumption.html

/inventory/index.html (main entry point with navbar + iframe loader)

2) index.html

Contains the Inventory Management header + nav bar

Instead of embedding all code, it has a single <iframe id="tabFrame"> or <div id="tabContent"> where other files load dynamically

Example:

<body>
  <div class="container">
    <h2>Inventory Management</h2>
    <ul class="nav nav-tabs">
      <li><a href="#" onclick="loadTab('dashboard.html')">Dashboard</a></li>
      <li><a href="#" onclick="loadTab('product-master.html')">Product Master</a></li>
      <li><a href="#" onclick="loadTab('categories.html')">Categories</a></li>
      <li><a href="#" onclick="loadTab('adjustments.html')">Add Inventory Items</a></li>
      <li><a href="#" onclick="loadTab('consumption.html')">Consumption</a></li>
    </ul>
    <div id="tabContent" class="mt-3"></div>
  </div>
  <script>
    async function loadTab(file) {
      const content = document.getElementById('tabContent');
      const resp = await fetch(`/inventory/${file}`);
      content.innerHTML = await resp.text();
    }
    document.addEventListener("DOMContentLoaded", () => loadTab('dashboard.html'));
  </script>
</body>

3) Example tab file (product-master.html)
<div>
  <h3>Product Master</h3>
  <button id="btnAddProduct" class="btn btn-primary">+ Add Product</button>
  <table class="table" id="productTable">
    <thead>
      <tr>
        <th>SKU</th><th>Name</th><th>Category</th><th>Stock</th><th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
  function loadProducts() {
    let products = JSON.parse(localStorage.getItem('inventory.products') || '[]');
    const tbody = document.querySelector('#productTable tbody');
    tbody.innerHTML = '';
    products.forEach(p => {
      tbody.innerHTML += `
        <tr>
          <td>${p.sku}</td>
          <td>${p.name}</td>
          <td>${p.categoryId}</td>
          <td>${p.stock}</td>
          <td>
            <button onclick="editProduct('${p.id}')">‚úèÔ∏è</button>
            <button onclick="deleteProduct('${p.id}')">üóëÔ∏è</button>
          </td>
        </tr>`;
    });
  }

  function addProduct() {
    const products = JSON.parse(localStorage.getItem('inventory.products') || '[]');
    const newProduct = { id: Date.now(), sku: "SKU-" + (products.length+1), name: "Sample Product", categoryId: "cat1", stock: 10 };
    products.push(newProduct);
    localStorage.setItem('inventory.products', JSON.stringify(products));
    loadProducts();
  }

  document.getElementById('btnAddProduct').addEventListener('click', addProduct);
  loadProducts();
</script>

4) Rules

Each tab file (categories.html, consumption.html, etc.) follows the same structure:

HTML UI for that tab

Inline <script> with CRUD logic only for that tab

Use localStorage keys for data:

inventory.products

inventory.categories

inventory.adjustments

inventory.consumptions

No cross-tab JS mixing; each file maintains itself.

5) Acceptance criteria

UI looks exactly the same as before (tabs + content + modals).

Each tab loads its own code when clicked.

CRUD (Add/Edit/Delete) works in all tabs.

No ‚Äúfunction not defined‚Äù or ‚Äúempty page‚Äù errors.

Code is modular: every tab has its own HTML+JS file for easy maintenance.

‚ö° This way, you get simple maintainability:

One index.html for navigation

One separate file per tab with its own HTML+JS combined