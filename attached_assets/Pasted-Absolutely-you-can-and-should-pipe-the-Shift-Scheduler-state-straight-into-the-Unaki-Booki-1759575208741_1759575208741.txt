Absolutely — you can (and should) pipe the **Shift Scheduler** state straight into the **Unaki Booking** view so bookings respect:

* out-of-office (field work)
* breaks
* leave / not scheduled / off-duty windows

Below is a tight, practical plan with copy-pasteable backend and frontend changes.

---

# Goal

In the Unaki Booking page for a given date, show each staff row with:

* **bookable** windows only inside shift hours
* **yellow** blocks for **breaks**
* **red** blocks for **out-of-office**
* **dark gray** for **not scheduled / leave / off-duty**
* prevent creating/editing bookings into any blocked time

---

# 1) Backend: enrich `/api/unaki/schedule?date=YYYY-MM-DD`

### What we’ll add

* For each staff, include their **shift window** (start/end), **break window(s)**, and **OOO windows** from `shift_logs`.
* Compute `is_working` and `shift_status` for that date.
* Return **blocks** Unaki UI can draw over the timeline.

### SQL (works for SQLite/Postgres/MySQL with minor time fn tweaks)

```sql
-- 1) Find shift_management covering the date for each staff
SELECT
  sm.id AS shift_management_id,
  sm.staff_id,
  sm.from_date,
  sm.to_date
FROM shift_management sm
WHERE DATE(:target_date) BETWEEN DATE(sm.from_date) AND DATE(sm.to_date);
```

```sql
-- 2) The daily row in shift_logs for that staff+date
SELECT
  sl.id,
  sl.shift_management_id,
  sl.individual_date,
  sl.shift_start_time,
  sl.shift_end_time,
  sl.break_start_time,
  sl.break_end_time,
  sl.out_of_office_start,
  sl.out_of_office_end,
  sl.out_of_office_reason,
  sl.status
FROM shift_logs sl
WHERE sl.shift_management_id = :sm_id
  AND DATE(sl.individual_date) = DATE(:target_date)
LIMIT 1;
```

### Flask (integrated in your existing `app.py` schedule endpoint)

```python
from datetime import datetime, date, time
from flask import request, jsonify

def to_str(t):  # t may be None or "HH:MM:SS"; normalize to "HH:MM"
    if not t: return None
    s = str(t)
    return s[:5] if len(s) >= 5 else s

@app.route('/api/unaki/schedule')
def unaki_schedule():
    target_date = request.args.get('date')  # 'YYYY-MM-DD'
    # Load staff list as you already do (id, name, etc.)
    staff_rows = load_all_staff()  # [{id, name, ...}]

    # 1) build a map of staff_id -> shift/day info
    shift_map = {}
    for s in staff_rows:
        sm = db.execute("""
            SELECT id, from_date, to_date
            FROM shift_management
            WHERE staff_id = ?
              AND DATE(?) BETWEEN DATE(from_date) AND DATE(to_date)
            LIMIT 1
        """, (s['id'], target_date)).fetchone()

        if not sm:
            # Not scheduled for this date
            shift_map[s['id']] = {
                "is_working": False,
                "shift_status": "not_scheduled",
                "shift_start": None,
                "shift_end": None,
                "breaks": [],
                "ooo": []
            }
            continue

        sl = db.execute("""
            SELECT
              shift_start_time, shift_end_time,
              break_start_time, break_end_time,
              out_of_office_start, out_of_office_end, out_of_office_reason,
              status
            FROM shift_logs
            WHERE shift_management_id = ?
              AND DATE(individual_date) = DATE(?)
            LIMIT 1
        """, (sm['id'], target_date)).fetchone()

        if not sl:
            # management exists but no day row → treat as not scheduled that day
            shift_map[s['id']] = {
                "is_working": False,
                "shift_status": "not_scheduled",
                "shift_start": None,
                "shift_end": None,
                "breaks": [],
                "ooo": []
            }
            continue

        is_working = bool(sl['shift_start_time'] and sl['shift_end_time'])
        breaks = []
        if sl['break_start_time'] and sl['break_end_time']:
            breaks.append({
                "start": to_str(sl['break_start_time']),
                "end": to_str(sl['break_end_time'])
            })

        ooo = []
        if sl['out_of_office_start'] and sl['out_of_office_end']:
            ooo.append({
                "start": to_str(sl['out_of_office_start']),
                "end": to_str(sl['out_of_office_end']),
                "reason": sl['out_of_office_reason'] or ""
            })

        shift_map[s['id']] = {
            "is_working": is_working,
            "shift_status": sl['status'] or ("scheduled" if is_working else "not_scheduled"),
            "shift_start": to_str(sl['shift_start_time']),
            "shift_end": to_str(sl['shift_end_time']),
            "breaks": breaks,
            "ooo": ooo
        }

    # 2) load bookings (you already do this)
    appts = load_bookings_for_date(target_date)

    # 3) shape response
    staff_payload = []
    for s in staff_rows:
        si = shift_map.get(s['id'], {
            "is_working": False, "shift_status": "not_scheduled",
            "shift_start": None, "shift_end": None, "breaks": [], "ooo": []
        })
        staff_payload.append({
            "id": s['id'],
            "name": s['name'],
            "shift_start": si["shift_start"],       # "08:00" or null
            "shift_end": si["shift_end"],           # "17:15" or null
            "breaks": si["breaks"],                 # [{start,end}]
            "ooo": si["ooo"],                       # [{start,end,reason}]
            "is_working": si["is_working"],
            "shift_status": si["shift_status"]
        })

    return jsonify({
        "success": True,
        "date": target_date,
        "staff": staff_payload,
        "appointments": appts,
        # (optional) a flat list of break/ooo blocks you might also show in a legend
    })
```

> If a staff has **multiple** breaks/OOO windows in a day, return arrays with multiple objects. The JS below already supports `[].forEach`.

---

# 2) Backend: upgrade **conflict checking** to include shift rules

Your existing overlap check looks only at bookings. Add **hard constraints**:

* Must be **within shift_start/shift_end**
* Must **not** overlap any **break**
* Must **not** overlap any **OOO** window
* Must **not** be allowed when **not scheduled / leave**

```python
def overlaps(a_start, a_end, b_start, b_end):
    # times are "HH:MM" strings; parse to minutes
    def to_min(s): h, m = map(int, s.split(':')); return h*60+m
    as_, ae, bs, be = map(to_min, (a_start, a_end, b_start, b_end))
    return ae > bs and as_ < be  # strict overlap

def validate_against_shift(staff_id, date_str, start_hm, end_hm):
    # fetch shift row like above
    si = get_shift_info_for_staff_date(staff_id, date_str)
    if not si["is_working"]:
        return False, "Staff is not scheduled / on leave."

    # inside shift window?
    if not (si["shift_start"] and si["shift_end"]):
        return False, "No shift window set for this staff."

    if not (start_hm >= si["shift_start"] and end_hm <= si["shift_end"]):
        return False, "Outside of shift hours."

    # break windows
    for br in si["breaks"]:
        if overlaps(start_hm, end_hm, br["start"], br["end"]):
            return False, "During break time."

    # out of office
    for oo in si["ooo"]:
        if overlaps(start_hm, end_hm, oo["start"], oo["end"]):
            return False, f"Out of office: {oo.get('reason','')}"

    return True, None
```

Use this in both:

* `POST /api/unaki/check-conflicts`
* `POST /api/unaki/appointments` and `PUT /api/unaki/bookings/{id}`

Before you query booking overlaps, short-circuit on shift violations to give immediate, precise errors.

---

# 3) Frontend: render shift overlays in the timeline

You already compute pixel positions from **9:00 baseline** with `140px/hour`. Reuse that for **break** and **OOO** blocks.

### Helper (JS)

```javascript
const HOUR_WIDTH = 140;
const DAY_START_HOUR = 9; // baseline

function hmToLeft(hhmm) {
  const [h,m] = hhmm.split(':').map(Number);
  return ((h + m/60) - DAY_START_HOUR) * HOUR_WIDTH;
}
function hmToWidth(start, end) {
  const [sh,sm] = start.split(':').map(Number);
  const [eh,em] = end.split(':').map(Number);
  return ((eh + em/60) - (sh + sm/60)) * HOUR_WIDTH;
}
```

### When drawing each **staff row**

```javascript
function renderStaffRow(staff) {
  // ... your existing row scaffolding

  // 1) Off-duty / not scheduled background
  if (!staff.is_working || !staff.shift_start || !staff.shift_end) {
    rowEl.classList.add('off-duty'); // CSS: dark gray bg, pointer-events:none
  } else {
    // Optional: shade before shift or after shift
    addShadeBlock(rowEl, 9, staff.shift_start);   // before shift
    addShadeBlock(rowEl, staff.shift_end, '22:00'); // after shift
  }

  // 2) Break overlays (yellow)
  (staff.breaks || []).forEach(br => {
    const left = hmToLeft(br.start);
    const width = hmToWidth(br.start, br.end);
    const el = document.createElement('div');
    el.className = 'overlay-break';
    el.style.left = `${left}px`;
    el.style.width = `${width}px`;
    el.title = `Break: ${br.start}–${br.end}`;
    rowEl.appendChild(el);
  });

  // 3) Out-of-office overlays (red)
  (staff.ooo || []).forEach(oo => {
    const left = hmToLeft(oo.start);
    const width = hmToWidth(oo.start, oo.end);
    const el = document.createElement('div');
    el.className = 'overlay-ooo';
    el.style.left = `${left}px`;
    el.style.width = `${width}px`;
    el.title = `Out of office: ${oo.start}–${oo.end}${oo.reason ? ' • ' + oo.reason : ''}`;
    rowEl.appendChild(el);
  });

  // 4) Appointments (existing logic)
  renderAppointmentsForStaff(rowEl, staff.id);
}
```

### Tiny helpers

```javascript
function addShadeBlock(rowEl, startHH, endHHMM) {
  const start = typeof startHH === 'number' ? `${String(startHH).padStart(2,'0')}:00` : startHH;
  const left = hmToLeft(start);
  const width = hmToWidth(start, endHHMM);
  if (width <= 0) return;
  const el = document.createElement('div');
  el.className = 'overlay-off';
  el.style.left = `${left}px`;
  el.style.width = `${width}px`;
  rowEl.appendChild(el);
}
```

### CSS (Bootstrap-friendly)

```css
.timeline-row { position: relative; height:110px; }
.overlay-break {
  position:absolute; top:0; bottom:0;
  background: rgba(255, 193, 7, 0.35);  /* warning/yellow */
  pointer-events: none;
}
.overlay-ooo {
  position:absolute; top:0; bottom:0;
  background: rgba(220, 53, 69, 0.35);  /* danger/red */
  pointer-events: none;
}
.overlay-off {
  position:absolute; top:0; bottom:0;
  background: rgba(108, 117, 125, 0.25); /* secondary/gray */
  pointer-events:none;
}
.off-duty {
  background: rgba(108, 117, 125, 0.2);
}
```

---

# 4) Frontend: disable booking into blocked time

When the user picks **Staff/Date/Start Time** in the modal:

* Call `/api/unaki/check-conflicts` **including shift check** (backend above).
* If the response indicates **outside shift / break / OOO**, show a warning and prevent submit.
* In the grid, when user drags/creates a block, **snap** the start/end to the nearest allowed window (optional).

Example request body (unchanged):

```json
{ "staff_id": 11, "date": "2025-10-04", "start_time": "13:15", "end_time": "14:00" }
```

Example response on OOO:

```json
{ "success": false, "has_conflicts": true, "reason": "Out of office: Client visit" }
```

---

# 5) Status rules (recommended)

* If a day has any **OOO** window → keep `shift_status = 'scheduled'` but mark the blocks with a **red overlay**. Don’t over-load status; the overlay communicates the constraint.
* If there’s **no shift** or shift row missing → treat entire row as **off-duty**.
* If `status in ('absent','holiday')` → full-row **off-duty**.
* Completed bookings remain green; cancelled gray; but overlays sit **under** appointment blocks so you can still see bookings that were made earlier.

---

# 6) Edge cases

* **Multiple breaks or OOO**: return arrays; the renderer already loops through them.
* **Spanning midnight**: if you ever allow it, split into day-bound segments before returning to UI (your grid is 09:00–22:00).
* **No `shift_logs` row** for the date but management exists: treat as not scheduled unless you want to inherit a template; above code marks off-duty.

---

# 7) Performance tips

* Pre-fetch all `shift_logs` for the date in **one query** with a `JOIN` to staff, then build a map in Python.
* Cache `/api/unaki/schedule?date=X` for ~15–30s; the page refreshes frequently with no need to hammer DB.

---

# 8) Quick checklist

* [ ] Migration: `shift_logs` has `out_of_office_start`, `out_of_office_end`, `out_of_office_reason` (done earlier).
* [ ] `/api/unaki/schedule` returns `breaks[]` and `ooo[]` per staff.
* [ ] `/api/unaki/check-conflicts` + create/update endpoints call `validate_against_shift(...)`.
* [ ] UI draws **yellow** breaks, **red** OOO, **gray** off-duty, and prevents creating bookings there.
* [ ] Context menu options (e.g., “Duplicate”, “Go to Billing”) are disabled if the duplicate would land in a blocked window.

---

If you want, I can tailor the exact SQL/ORM code to your stack (SQLite vs Postgres, raw SQL vs SQLAlchemy) and wire it into the exact lines of your `app.py`.
